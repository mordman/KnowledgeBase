### **1. Основы и архитектура Git**



## Оглавление
- [**1. Основы и архитектура Git**](#1-основы-и-архитектура-git)
  - [**Как бы вы объяснили Git человеку, который никогда с ним не работал?**](#как-бы-вы-объяснили-git-человеку-который-никогда-с-ним-не-работал)
  - [**Чем Git отличается от других систем контроля версий (например, SVN)?**](#чем-git-отличается-от-других-систем-контроля-версий-например-svn)
  - [**Что такое объектная модель Git?**](#что-такое-объектная-модель-git)
  - [**Что такое HEAD в Git?**](#что-такое-head-в-git)
- [**2. Ветвление и слияние**](#2-ветвление-и-слияние)
  - [**Какие стратегии ветвления вы использовали?**](#какие-стратегии-ветвления-вы-использовали)
  - [**Что такое rebase? Когда его стоит использовать?**](#что-такое-rebase-когда-его-стоит-использовать)
  - [**Как разрешить конфликт слияния?**](#как-разрешить-конфликт-слияния)
  - [**Что такое "detached HEAD"?**](#что-такое-detached-head)
- [**3. Работа с удалёнными репозиториями**](#3-работа-с-удалёнными-репозиториями)
  - [**Как работает `git fetch` и чем он отличается от `git pull`?**](#как-работает-git-fetch-и-чем-он-отличается-от-git-pull)
  - [**Что такое "bare repository"?**](#что-такое-bare-repository)
  - [**Как вы организуете работу с несколькими удалёнными репозиториями?**](#как-вы-организуете-работу-с-несколькими-удалёнными-репозиториями)
- [**4. Продвинутые возможности**](#4-продвинутые-возможности)
  - [**Что такое `git cherry-pick`?**](#что-такое-git-cherry-pick)
  - [**Как работает `git reset` (soft, mixed, hard)?**](#как-работает-git-reset-soft-mixed-hard)
  - [**Что такое `git stash`?**](#что-такое-git-stash)
  - [**Как откатить изменения, которые уже были закоммичены и отправлены в удалённый репозиторий?**](#как-откатить-изменения-которые-уже-были-закоммичены-и-отправлены-в-удалённый-репозиторий)
- [**5. Оптимизация и лучшие практики**](#5-оптимизация-и-лучшие-практики)
  - [**Как оптимизировать работу с большими репозиториями?**](#как-оптимизировать-работу-с-большими-репозиториями)
  - [**Что такое `.gitignore`?**](#что-такое-gitignore)
  - [**Как вы организуете коммиты?**](#как-вы-организуете-коммиты)
  - [**Что такое "git hooks"?**](#что-такое-git-hooks)
- [**6. Командная работа и CI/CD**](#6-командная-работа-и-cicd)
  - [**Как интегрировать Git с CI/CD?**](#как-интегрировать-git-с-cicd)
  - [**Какие подходы к код-ревью вы практикуете?**](#какие-подходы-к-код-ревью-вы-практикуете)
- [**7. Решение проблем**](#7-решение-проблем)
  - [**Как восстановить потерянные коммиты?**](#как-восстановить-потерянные-коммиты)
  - [**Что делать, если кто-то сделал `force push`?**](#что-делать-если-кто-то-сделал-force-push)
  - [**Как найти и исправить ошибки в истории коммитов?**](#как-найти-и-исправить-ошибки-в-истории-коммитов)

  - [**Как бы вы объяснили Git человеку, который никогда с ним не работал?**](#как-бы-вы-объяснили-git-человеку-который-никогда-с-ним-не-работал)
  - [**Чем Git отличается от других систем контроля версий (например, SVN)?**](#чем-git-отличается-от-других-систем-контроля-версий-например-svn)
  - [**Что такое объектная модель Git?**](#что-такое-объектная-модель-git)
  - [**Что такое HEAD в Git?**](#что-такое-head-в-git)
  - [**Какие стратегии ветвления вы использовали?**](#какие-стратегии-ветвления-вы-использовали)
  - [**Что такое rebase? Когда его стоит использовать?**](#что-такое-rebase-когда-его-стоит-использовать)
  - [**Как разрешить конфликт слияния?**](#как-разрешить-конфликт-слияния)
  - [**Что такое "detached HEAD"?**](#что-такое-detached-head)
  - [**Как работает `git fetch` и чем он отличается от `git pull`?**](#как-работает-git-fetch-и-чем-он-отличается-от-git-pull)
  - [**Что такое "bare repository"?**](#что-такое-bare-repository)
  - [**Как вы организуете работу с несколькими удалёнными репозиториями?**](#как-вы-организуете-работу-с-несколькими-удалёнными-репозиториями)
  - [**Что такое `git cherry-pick`?**](#что-такое-git-cherry-pick)
  - [**Как работает `git reset` (soft, mixed, hard)?**](#как-работает-git-reset-soft-mixed-hard)
  - [**Что такое `git stash`?**](#что-такое-git-stash)
  - [**Как откатить изменения, которые уже были закоммичены и отправлены в удалённый репозиторий?**](#как-откатить-изменения-которые-уже-были-закоммичены-и-отправлены-в-удалённый-репозиторий)
  - [**Как оптимизировать работу с большими репозиториями?**](#как-оптимизировать-работу-с-большими-репозиториями)
  - [**Что такое `.gitignore`?**](#что-такое-gitignore)
  - [**Как вы организуете коммиты?**](#как-вы-организуете-коммиты)
  - [**Что такое "git hooks"?**](#что-такое-git-hooks)
  - [**Как интегрировать Git с CI/CD?**](#как-интегрировать-git-с-cicd)
  - [**Какие подходы к код-ревью вы практикуете?**](#какие-подходы-к-код-ревью-вы-практикуете)
  - [**Как восстановить потерянные коммиты?**](#как-восстановить-потерянные-коммиты)
  - [**Что делать, если кто-то сделал `force push`?**](#что-делать-если-кто-то-сделал-force-push)
  - [**Как найти и исправить ошибки в истории коммитов?**](#как-найти-и-исправить-ошибки-в-истории-коммитов)
#### **Как бы вы объяснили Git человеку, который никогда с ним не работал?**
Git — это распределённая система контроля версий, которая позволяет отслеживать изменения в коде, работать над проектом совместно с другими разработчиками и возвращаться к предыдущим версиям файлов. Представьте Git как "машину времени" для вашего кода: вы можете сохранять состояния проекта (коммиты), создавать ветки для экспериментов и объединять их обратно, если всё прошло успешно.

#### **Чем Git отличается от других систем контроля версий (например, SVN)?**
- **Распределённость:** В Git каждый пользователь имеет полную копию репозитория, включая историю. В SVN история хранится на центральном сервере.
- **Производительность:** Операции в Git (коммиты, ветвление) выполняются локально и почти мгновенно.
- **Ветвление:** В Git ветвление лёгкое и дёшевое, что позволяет создавать ветки для каждой задачи. В SVN ветвление — более тяжёлая операция.
- **Модель данных:** Git хранит данные как снимки (snapshots) файловой системы, а не как изменения между версиями.

#### **Что такое объектная модель Git?**
Git хранит данные в виде четырёх типов объектов:
- **Blob** — содержимое файла.
- **Tree** — структура директорий и файлов (указывает на blob и другие tree).
- **Commit** — снимок проекта в определённый момент времени (указывает на tree, родительские коммиты и метаданные).
- **Tag** — указатель на конкретный коммит (обычно используется для релизов).

#### **Что такое HEAD в Git?**
`HEAD` — это указатель на текущий коммит в ветке. Он показывает, где вы находитесь в истории коммитов. Например, если вы в ветке `main`, `HEAD` указывает на последний коммит в `main`. Отличается от рабочей директории (фактические файлы) и индекса (staging area, где формируется следующий коммит).

---

### **2. Ветвление и слияние**

#### **Какие стратегии ветвления вы использовали?**
- **Git Flow:** Использует ветки `main`, `develop`, `feature`, `release`, `hotfix`. Подходит для проектов с чёткими релизами.
- **GitHub Flow:** Проще — только `main` и `feature`-ветки. Подходит для непрерывной интеграции.
- **Trunk-Based Development:** Все работают в одной ветке (`main` или `trunk`), часто используют feature flags. Подходит для команд с высокой автоматизацией тестирования.

#### **Что такое rebase? Когда его стоит использовать?**
`git rebase` — это перенос коммитов из одной ветки на вершину другой. Используется для:
- Очистки истории (линейная история вместо множества merge-коммитов).
- Синхронизации своей ветки с последними изменениями в `main`.

**Когда избегать:**
- Если ветка уже опубликована и над ней работают другие (rebase переписывает историю).
- Если есть конфликты, которые сложно разрешить.

#### **Как разрешить конфликт слияния?**
1. Git отмечает конфликтующие файлы.
2. Открываете файл, находите метки `<<<<<<<`, `=======`, `>>>>>>>`.
3. Редактируете файл, оставляя нужный код.
4. Сохраняете изменения, добавляете файл в индекс (`git add`) и завершаете merge (`git commit`).

#### **Что такое "detached HEAD"?**
Состояние, когда `HEAD` указывает не на ветку, а на конкретный коммит. Полезно для:
- Просмотра старого состояния проекта.
- Создания ветки из конкретного коммита.

---

### **3. Работа с удалёнными репозиториями**

#### **Как работает `git fetch` и чем он отличается от `git pull`?**
- `git fetch` — скачивает изменения из удалённого репозитория, но не сливает их с локальными ветками.
- `git pull` = `git fetch` + `git merge` (или `git rebase`, если настроено).

#### **Что такое "bare repository"?**
Репозиторий без рабочей директории, содержащий только историю и метаданные. Используется для центральных репозиториев (например, на сервере).

#### **Как вы организуете работу с несколькими удалёнными репозиториями?**
- `origin` — основной удалённый репозиторий.
- `upstream` — репозиторий, откуда вы форкаете проект (например, на GitHub).
- Используйте `git remote add` для добавления новых удалённых репозиториев.

---

### **4. Продвинутые возможности**

#### **Что такое `git cherry-pick`?**
Команда для применения изменений из конкретного коммита в текущую ветку. Полезно, если нужно перенести один коммит из другой ветки.

#### **Как работает `git reset` (soft, mixed, hard)?**
- `soft` — сбрасывает `HEAD`, но оставляет изменения в индексе и рабочей директории.
- `mixed` — сбрасывает `HEAD` и индекс, но оставляет изменения в рабочей директории.
- `hard` — полностью сбрасывает `HEAD`, индекс и рабочую директорию (опасно: данные теряются).

#### **Что такое `git stash`?**
Команда для временного сохранения незакоммиченных изменений, чтобы переключиться на другую задачу. Позже изменения можно вернуть (`git stash pop`).

#### **Как откатить изменения, которые уже были закоммичены и отправлены в удалённый репозиторий?**
1. `git revert` — создаёт новый коммит, отменяющий изменения (безопасно для публичных веток).
2. `git reset` + `git push --force` — переписывает историю (опасно, если над веткой работают другие).

---

### **5. Оптимизация и лучшие практики**

#### **Как оптимизировать работу с большими репозиториями?**
- Использовать `git shallow clone` для скачивания только последних коммитов.
- Регулярно запускать `git gc` для очистки мусора.
- Использовать `.gitignore` для исключения ненужных файлов.

#### **Что такое `.gitignore`?**
Файл, в котором перечислены файлы и директории, которые Git должен игнорировать (например, `node_modules/`, `*.log`).

#### **Как вы организуете коммиты?**
- Атомарные коммиты (один коммит — одно логическое изменение).
- Сообщения коммитов: краткое описание (50 символов) + подробности (если нужно).

#### **Что такое "git hooks"?**
Скрипты, которые автоматически запускаются на определённых этапах работы с Git (например, перед коммитом или пушем). Пример: проверка стиля кода перед коммитом.

---

### **6. Командная работа и CI/CD**

#### **Как интегрировать Git с CI/CD?**
- Настраивать автоматическое запускание тестов при пуше в ветку.
- Использовать защищённые ветки (protected branches) для `main`.
- Настраивать проверку код-ревью перед слиянием.

#### **Какие подходы к код-ревью вы практикуете?**
- Pull Request (PR) в GitHub/GitLab.
- Обязательное ревью перед слиянием в `main`.
- Использование чек-листов для ревью.

---

### **7. Решение проблем**

#### **Как восстановить потерянные коммиты?**
- Использовать `git reflog` для поиска потерянных коммитов.
- `git checkout -b new-branch <commit-hash>` для восстановления ветки.

#### **Что делать, если кто-то сделал `force push`?**
- Попросить не использовать `force push` в общих ветках.
- Восстановить состояние с помощью `git reflog` или резервной копии.

#### **Как найти и исправить ошибки в истории коммитов?**
- `git bisect` — бинарный поиск по истории для нахождения "плохого" коммита.
- `git blame` — кто и когда изменил конкретную строку.

---