## Вопрос
1. Как это работает
2. Что выведется
3. Как можно улучшить

```c#
using System;
using System.Linq;
using System.Collections.Generic;
					
public class Program
{
	public static void Main()
	{
		var watch = System.Diagnostics.Stopwatch.StartNew();

		Console.WriteLine("->Run...");
		
		int i = 0;
		var data = new List<int>(){1,2,3,4,5,6};
		
		var test = data.Where(t=>t>3).Select(_=>i++);
		Console.WriteLine($"i:{i} test:{test}");//i=? test=?
		
		test = data.Where(t=>t>3).Select(_=>i++).ToList();
		Console.WriteLine($"i:{i} test:{test}");//i=? test=?

		watch.Stop();
		var elapsedMs = watch.ElapsedMilliseconds;
		Console.WriteLine($"<-End. Elapsed:{elapsedMs}");
	}
}
```

## Ответ
Давай разберём, как работает этот код, и что можно улучшить.

---

## **Как работает код**

### **1. Инициализация и подготовка**
- Создаётся `Stopwatch` для измерения времени выполнения.
- Объявляется переменная `i = 0` и список `data` с числами от 1 до 6.

---

### **2. Первый запрос LINQ (без `ToList()`)**
```csharp
var test = data.Where(t => t > 3).Select(_ => i++);
Console.WriteLine($"i:{i} test:{test}");
```
- **`data.Where(t => t > 3)`**: Фильтрует элементы списка `data`, оставляя только те, которые больше 3 (то есть 4, 5, 6).
- **`.Select(_ => i++)`**: Для каждого отфильтрованного элемента выполняется инкремент переменной `i`, но **само выражение не выполняется сразу**, потому что LINQ использует **отложенное выполнение (deferred execution)**.
- **Результат**: Переменная `i` остаётся равной `0`, так как запрос ещё не выполнен. `test` — это объект `IEnumerable<int>`, который ещё не вычислен.

---

### **3. Второй запрос LINQ (с `ToList()`)**
```csharp
test = data.Where(t => t > 3).Select(_ => i++).ToList();
Console.WriteLine($"i:{i} test:{test}");
```
- **`.ToList()`**: Принудительно выполняет запрос LINQ, перебирая все элементы, которые прошли фильтрацию (`4, 5, 6`).
- **`i++`**: Для каждого из трёх элементов (`4, 5, 6`) выполняется инкремент `i`. В результате `i` становится равным `3`.
- **Результат**: `test` — это список `[0, 1, 2]` (значения `i` до инкремента), а `i` теперь равно `3`.

---

## **Что можно улучшить**

### **1. Побочные эффекты в LINQ-запросах**
- **Проблема**: Использование `i++` внутри `Select` приводит к побочным эффектам, что противоречит принципам функционального подхода LINQ. Код становится менее предсказуемым и сложным для отладки.
- **Решение**: Избегайте побочных эффектов в LINQ-запросах. Если нужно посчитать количество элементов, используйте `Count()`:
  ```csharp
  int count = data.Count(t => t > 3);
  ```

---

### **2. Отложенное выполнение**
- **Проблема**: Если не вызвать `ToList()`, `ToArray()` или другой метод, который принудительно выполняет запрос, то код может работать не так, как ожидается.
- **Решение**: Если нужно сразу получить результат, используйте `ToList()` или `ToArray()`:
  ```csharp
  var filteredData = data.Where(t => t > 3).ToList();
  ```

---

## **Выводы**
- **LINQ-запросы с побочными эффектами** (например, `i++`) могут приводить к неожиданному поведению.
- **Отложенное выполнение** означает, что запрос не выполняется до явного вызова (`ToList()`, `ToArray()` и т.д.).