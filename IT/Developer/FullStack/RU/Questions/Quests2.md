### **PostgreSQL**

**1. Каковы преимущества и недостатки использования индексов в PostgreSQL?**

*   **Преимущества:**
    *   **Скорость:** Кардинальное ускорение операций `SELECT`, `UPDATE`, `DELETE` (в условии `WHERE`) и `JOIN`.
    *   **Обеспечение уникальности:** Уникальные индексы гарантируют целостность данных.
    *   **Ускорение сортировки и группировки:** Индекс (особенно B-Tree) может предоставить уже отсортированные данные для `ORDER BY` и `GROUP BY`.
*   **Недостатки:**
    *   **Замедление операций записи:** При каждой `INSERT`, `UPDATE` или `DELETE` необходимо обновлять все соответствующие индексы.
    *   **Потребление дискового пространства:** Индексы занимают место на диске.
    *   **Избыточность:** Неправильный выбор индекса (например, на столбце с низкой селективностью) может не дать выгоды, но будет нести все недостатки.

**2. Расскажите о различных типах индексов в PostgreSQL.**

*   **B-Tree (Дерево):** Стандартный индекс по умолчанию. Подходит для точных совпадений (`=`), диапазонов (`BETWEEN`, `>`, `<`), сортировки. Работает с любым типом данных, поддерживающим порядок.
*   **Hash:** Быстрее B-Tree для операций строгого равенства (`=`), но не поддерживает диапазоны и сортировку. Данные в памяти, могут быть потеряны при сбое (требует `WAL` логирования).
*   **GIN (Generalized Inverted Index):** Для индексирования составных значений (массивы, JSONB, полнотекстовый поиск). Эффективен, когда один столбец содержит несколько значений для поиска (например, "есть ли в массиве элемент X?").
*   **GiST (Generalized Search Tree):** Подходит для данных, где понятие "близости" важнее точного совпадения: геометрические данные, полнотекстовый поиск, диапазоны. Может использоваться для `k-NN` поиска.
*   **SP-GiST (Space-Partitioned GiST):** Для неоднородных структур данных, таких как квадродеревья или префиксные деревья.
*   **BRIN (Block Range INdexes):** Эффективен для очень больших таблиц, где данные физически отсортированы на диске (например, временные ряды). Хранит сводную информацию о диапазонах страниц, занимает очень мало места.

**3. Что такое EXPLAIN ANALYZE и как его использовать для оптимизации запросов?**

*   **`EXPLAIN`** показывает предполагаемый план выполнения запроса, который планировщик PostgreSQL собирается использовать.
*   **`EXPLAIN ANALYZE`** *выполняет* запрос и показывает реальный план вместе с фактически затраченным временем и количеством строк.
*   **Как использовать:**
    1.  Запустить `EXPLAIN ANALYZE [your_query];`
    2.  Искать "узкие места": операции `Seq Scan` (полное сканирование таблицы) на больших таблицах, высокие значения `cost`, `actual time` и `rows`.
    3.  Анализировать разницу между `estimated rows` (столбец `rows`) и `actual rows`. Большая разница указывает на неверную статистику, что может привести к плохому плану.
    4.  На основе анализа добавлять индексы, переписывать запрос, использовать CTE или временные таблицы, обновлять статистику (`ANALYZE`).

**4. Какие существуют методы оптимизации медленных SQL-запросов?**

1.  **Использование `EXPLAIN ANALYZE`** для идентификации проблемных мест.
2.  **Добавление индексов** на столбцы в условиях `WHERE`, `JOIN`, `ORDER BY`.
3.  **Переписывание запроса:** Упрощение логики, замена подзапросов на `JOIN` или CTE, устранение `SELECT *`.
4.  **Нормализация и денормализация:** Иногда для ускорения чтения целесообразно немного денормализовать схему.
5.  **Партиционирование таблиц:** Разделение большой таблицы на меньшие по логическому признаку (например, по дате).
6.  **Настройка параметров сервера:** `shared_buffers`, `work_mem`, `maintenance_work_mem`.
7.  **Обновление статистики:** `ANALYZE table_name;`
8.  **Использование частичных индексов:** Индексирование только части данных (`CREATE INDEX ... WHERE condition`).

**5. Чем отличается MVCC от традиционных блокировок?**

*   **Традиционные блокировки (например, в Java):** Читающие потоки блокируют пишущие и наоборот. Это может приводить к contention (соревнованию) и низкому параллелизму.
*   **MVCC (Multiversion Concurrency Control):** Каждая транзакция видит "снимок" (snapshot) данных на момент своего начала. При `UPDATE` строка не перезаписывается, а создается ее новая версия. Это позволяет:
    *   **Читателям не блокировать писателей.**
    *   **Писателям не блокировать читателей.**
    *   Обеспечивать высокий уровень параллелизма. Плата за это — необходимость очистки старых версий строк (VACUUM) и возможное раздувание таблиц (bloat).

**6. Назовите различия между операторами JOIN типов INNER, LEFT OUTER, RIGHT OUTER и FULL OUTER.**

*   **`INNER JOIN`:** Возвращает только те строки, где есть совпадение в *обеих* таблицах.
*   **`LEFT [OUTER] JOIN`:** Возвращает *все* строки из левой таблицы и совпадающие строки из правой. Если совпадения нет, правые столбцы будут `NULL`.
*   **`RIGHT [OUTER] JOIN`:** Возвращает *все* строки из правой таблицы и совпадающие строки из левой. Если совпадения нет, левые столбцы будут `NULL`.
*   **`FULL [OUTER] JOIN`:** Возвращает все строки и из левой, и из правой таблицы. Если совпадения нет, недостающие столбцы заполняются `NULL`.

**7. Как реализовать полнотекстовый поиск в PostgreSQL?**

1.  **Преобразование текста:** Использовать функцию `to_tsvector([config], text)` для преобразования документа в список лексем (токенов) с позициями.
2.  **Преобразование запроса:** Использовать `to_tsquery([config], query)` для преобразования поискового запроса.
3.  **Сопоставление:** Использовать оператор `@@` для поиска (`tsvector @@ tsquery`).
4.  **Индексирование:** Создать GIN или GiST индекс по `tsvector` столбцу.
    ```sql
    -- Пример
    ALTER TABLE books ADD COLUMN text_search_vector tsvector;
    UPDATE books SET text_search_vector = to_tsvector('english', title || ' ' || description);
    CREATE INDEX idx_fts_books ON books USING GIN(text_search_vector);

    SELECT * FROM books WHERE text_search_vector @@ to_tsquery('english', 'postgres & optimization');
    ```

**8. Опишите процедуру миграции схемы базы данных с использованием утилит pg_dump и pg_restore.**

1.  **Дамп исходной БД:**
    `pg_dump -Fc -U username -h source_host -d source_db -f backup.dump`
    *   `-Fc`: Формат "custom", который лучше для `pg_restore`.
2.  **Создание новой БД (если нужно):**
    `createdb -U username -h target_host target_db`
3.  **Восстановление в целевую БД:**
    `pg_restore -U username -h target_host -d target_db --verbose backup.dump`
    *   Можно использовать флаги `-j N` для распараллеливания, `--clean` для предварительной очистки объектов.

**9. Какой механизм блокировки используется в транзакциях PostgreSQL?**

PostgreSQL использует *многопользовательские блокировки на уровне строк и таблиц* в сочетании с MVCC. Блокировки бывают:
*   **Блокировки строк:** `FOR UPDATE`, `FOR SHARE`.
*   **Блокировки таблиц:** `ACCESS SHARE`, `ROW SHARE`, `ROW EXCLUSIVE`, `SHARE UPDATE EXCLUSIVE`, `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE`, `ACCESS EXCLUSIVE`. Последняя — самая строгая, используется операциями `DROP TABLE`, `ALTER TABLE`, `VACUUM FULL` и блокирует все остальные операции.

**10. Почему иногда возникают deadlocks и как с ними бороться?**

*   **Причина:** Deadlock возникает, когда две или более транзакции ожидают друг друга, освобождения ресурсов, создавая циклическую зависимость. Например:
    *   Транзакция 1 блокирует строку A и хочет заблокировать строку B.
    *   Транзакция 2 блокирует строку B и хочет заблокировать строку A.
*   **Борьба:**
    1.  **Обнаружение:** PostgreSQL имеет детектор deadlock-ов, который аварийно завершает одну из транзакций с ошибкой `SQLSTATE 40P01`.
    2.  **Профилактика:**
        *   Захватывать блокировки в *последовательном порядке* во всех транзакциях (сначала всегда A, потом B).
        *   Использовать короткие транзакции.
        *   Использовать `LOCK TABLE` (редко).
        *   В приложении — реализовать повтор попытки (retry logic) при отлове ошибки deadlock.

---

### **C#/.NET Framework**

**1. Объясните разницу между static и instance методами класса.**

*   **Instance метод:** Принадлежит *экземпляру* (объекту) класса. Имеет доступ к нестатическим полям и методам через ключевое слово `this`.
*   **Static метод:** Принадлежит *самому классу*. Вызывается через имя класса (`ClassName.Method()`). Не имеет доступа к нестатическим членам, так как не связан с конкретным экземпляром.

**2. В чём разница между abstract классом и интерфейсом?**

*   **Abstract класс:**
    *   Может содержать как абстрактные (без реализации), так и конкретные методы с реализацией.
    *   Может содержать поля (переменные экземпляра).
    *   Наследование от абстрактного класса — отношение "is-a".
    *   Класс может наследовать только от *одного* абстрактного класса.
*   **Интерфейс (до C# 8.0):**
    *   Содержит только объявления методов, свойств, событий (без реализации).
    *   Не может содержать поля экземпляра.
    *   Реализация интерфейса — отношение "can-do" (способность).
    *   Класс может реализовывать *несколько* интерфейсов.
*   **C# 8.0+:** Интерфейсы могут содержать реализации по умолчанию (default interface methods), что стирает строгую границу, но основные различия в семантике и множественном наследовании остаются.

**3. Для чего используются обобщённые типы (generics)?**

*   **Типобезопасность:** Исключают необходимость приведения типов (cast) и ошибок в runtime.
*   **Производительность:** Избегают упаковки (boxing) значимых типов при использовании с `List<T>` и другими коллекциями.
*   **Повторное использование кода:** Позволяют писать алгоритмы и структуры данных, которые работают с любым типом.

**4. Как работает наследование классов в .NET?**

*   **Отношение "is-a":** Класс-потомок (derived) наследует все `public` и `protected` члены класса-родителя (base).
*   **Одиночное наследование:** Класс может наследовать только от *одного* класса.
*   **Полиморфизм:** Метод базового класса может быть переопределен в производном классе с помощью модификаторов `virtual` (в базовом) и `override` (в производном).
*   **Конструкторы:** Конструкторы не наследуются. Конструктор производного класса должен явно или неявно вызывать конструктор базового класса (`base()`).

**5. Перечислите ключевые принципы SOLID и приведите пример реализации каждого принципа.**

*   **S (Single Responsibility):** Класс должен иметь только одну причину для изменения.
    *   *Пример:* Класс `Order` не должен сам сохранять себя в БД. Этим должна заниматься отдельный класс `OrderRepository`.
*   **O (Open/Closed):** Классы должны быть открыты для расширения, но закрыты для модификации.
    *   *Пример:* Использование абстракций (интерфейсов). Вместо `if (type == A) ... else if (type == B) ...` создать интерфейс `ICalculator` и реализации `ACalculator`, `BCalculator`.
*   **L (Liskov Substitution):** Объекты базового класса должны быть заменяемы объектами производных классов без нарушения работы программы.
    *   *Пример:* Квадрат не должен наследовать от прямоугольника, если у прямоугольника есть отдельные методы `SetWidth` и `SetHeight`.
*   **I (Interface Segregation):** Много специализированных интерфейсов лучше, чем один универсальный.
    *   *Пример:* Вместо `IMonster` с методами `Attack()`, `Fly()`, `Swim()`, создать `IAttacker`, `IFlyer`, `ISwimmer`.
*   **D (Dependency Inversion):** Зависимости должны строиться на абстракциях, а не на деталях.
    *   *Пример:* Высокоуровневый модуль `ReportService` должен зависеть от интерфейса `IDataProvider`, а не от конкретного класса `SqlDataProvider`. Конкретная реализация внедряется через конструктор (Dependency Injection).

**6. Какие механизмы асинхронного программирования есть в C# (.NET)?**

1.  **Модель Async/Await (`async`/`await`):** Ключевые слова, позволяющие писать асинхронный код, который выглядит как синхронный. Основан на `Task` и `Task<T>`.
2.  **Task Parallel Library (TPL):** Классы `Task`, `Task<T>`, `Parallel.For`, `Parallel.ForEach` для управления асинхронными операциями и параллелизма.
3.  **Классические паттерны:** `IAsyncResult` (Begin/End pattern) и event-based pattern (EAP) — устаревшие, но встречаются в legacy-коде.

**7. Опишите использование методов LINQ для обработки коллекций объектов.**

LINQ (Language Integrated Query) предоставляет два синтаксиса:
*   **Query Syntax:** Похож на SQL.
    `var results = from item in collection where item.Age > 18 select item.Name;`
*   **Method Syntax (на основе расширяющих методов):**
    `var results = collection.Where(item => item.Age > 18).Select(item => item.Name);`
    Основные методы: `Where`, `Select`, `OrderBy`, `GroupBy`, `Join`, `First`, `FirstOrDefault`, `Single`, `Any`, `All`, `Aggregate`.

**8. Приведите пример конструкции using и её предназначение.**

*   **Предназначение:** Обеспечивает корректное освобождение неуправляемых ресурсов (например, файлов, соединений с БД). Реализует шаблон IDisposable.
*   **Пример:**
    ```csharp
    using (var connection = new SqlConnection(connectionString))
    {
        connection.Open();
        // Работа с соединением...
    } // connection.Dispose() будет вызван автоматически, даже в случае исключения
    ```
    В C# 8.0+ можно использовать using declaration:
    `using var connection = new SqlConnection(connectionString);`

**9. Когда лучше использовать struct, а когда class?**

*   **`struct` (значимый тип):**
    *   Когда тип представляет одно значение (например, `Point`, `Coordinate`).
    *   Размер экземпляра небольшой (обычно до 16-24 байт).
    *   Он неизменяем (immutable).
    *   Он часто кратковременно живет и не требует полиморфизма.
    *   Хранится в стеке (stack) или внутри родительского объекта, что уменьшает нагрузку на GC.
*   **`class` (ссылочный тип):**
    *   Когда тип представляет сложный объект с поведением.
    *   Когда требуется наследование и полиморфизм.
    *   Когда размер может быть большим.
    *   Когда время жизни объекта не очевидно, и он должен храниться в куче (heap).

**10. Как устроены делегаты и события в C#?**

*   **Делегат (Delegate):** Типобезопасный указатель на функцию. Определяет сигнатуру метода. Позволяет передавать методы как аргументы.
    `public delegate int MathOperation(int a, int b);`
*   **Событие (Event):** Обёртка над делегатом, реализующая паттерн "Издатель-Подписчик". Предоставляет ключевые слова `event`, `add` и `remove`. Ограничивает возможность подписчиков напрямую вызывать событие (только `+=` и `-=`).
    ```csharp
    public class Publisher
    {
        public event EventHandler<MyEventArgs> MyEvent;
        protected virtual void OnMyEvent(MyEventArgs e) => MyEvent?.Invoke(this, e);
    }
    ```

---

### **Windows Forms / DevExpress**

**1. Какие особенности проектирования UI имеются в среде разработки Windows Forms?**

*   **Drag-and-Drop Designer:** Визуальный конструктор для быстрого прототипирования.
*   **Событийная модель:** Легкая привязка логики к событиям UI (клик, наведение, изменение текста).
*   **Layout-менеджеры:** `TableLayoutPanel`, `FlowLayoutPanel`, `SplitContainer` для создания масштабируемых интерфейсов.
*   **Привязка данных (DataBinding):** Позволяет связывать свойства элементов управления со свойствами объектов или источниками данных.

**2. Есть ли отличия между обычными элементами управления Windows Forms и компонентами DevExpress?**

*   **Да, значительные:**
    *   **Внешний вид (Themes/Skins):** DevExpress предоставляет богатую библиотеку скинов (Office, Visual Studio стили).
    *   **Функциональность:** Стандартный `DataGridView` vs `GridControl` от DevExpress. Последний имеет встроенную сортировку, группировку, фильтрацию, итоги, мастер-деталь, экспорт в различные форматы "из коробки".
    *   **Производительность:** Компоненты DevExpress часто оптимизированы для работы с большими объемами данных.
    *   **Дополнительные контролы:** `ChartControl`, `PivotGrid`, `RibbonControl`, `DockPanel`, которых нет в стандартной поставке WinForms.

**3. Поделитесь опытом интеграции компонентов DevExpress GridControl в проект.**

1.  **Установка:** Добавить пакеты DevExpress через NuGet (`DevExpress.Win.Design`, `DevExpress.Data` и т.д.).
2.  **Добавление на форму:** Перетащить `GridControl` и `GridView` (или `BandedGridView`) из панели элементов DevExpress.
3.  **Привязка данных:** Установить свойство `GridControl.DataSource` к `BindingSource`, `DataSet`, `IList` и т.д.
4.  **Настройка колонок:** Использовать дизайнер колонок или настраивать их в коде через событие `GridControl.ViewRegistered`.
5.  **Включение фич:** Включить `OptionsView.ShowGroupPanel`, `OptionsView.ShowAutoFilterRow`, `OptionsView.ShowFooter`.

**4. Приведите пример сложной настройки отображения таблиц с большим количеством строк и столбцов.**

*   **Виртуализация данных:** Убедиться, что `GridControl` использует Server Mode (`GridControl.ServerMode = true`) или Instant Feedback Mode для работы с большими данными без их полной загрузки в память.
*   **Группировка колонок:** Использовать `BandedGridView` для организации колонок в логические группы (банды).
*   **Условное форматирование:** Использовать `Appearance`, `FormatConditions` для подсветки строк/ячеек на основе значений.
*   **Фильтрация и поиск:** Настроить `FilterEditor`, выпадающие фильтры.
*   **Закрепление колонок (Pinning):** `OptionsView.ColumnFixedWidth` и настройка фиксации важных колонок.

**5. Расскажите о возможностях визуализации диаграмм с помощью библиотеки DevExpress.**

`ChartControl` предоставляет:
*   **Богатый набор типов диаграмм:** Bar, Line, Pie, Area, Financial (Stock), Polar, Radar, 3D-диаграммы.
*   **Интерактивность:** Zoom, Scroll, Pan, Tooltips, Crosshair.
*   **Привязка данных:** Гибкая привязка к различным источникам данных.
*   **Кастомизация:** Полный контроль над осями, легендой, сериями, панелями.
*   **Анимация и эффекты.**

**6. Возможны ли кастомизации элементов управления DevExpress, и как это делается?**

*   **Да, глубоко возможны.**
    1.  **Стили и Appearance:** Глобальная настройка через `UserLookAndFeel` или точечная через события `CustomDrawCell`, `CustomDraw...`.
    2.  **Рендеринг:** Создание кастомных `RepositoryItem` для ячеек GridView (например, кастомный редактор).
    3.  **Создание производных контролов:** Наследование от стандартных контролов DevExpress для добавления специфичной логики.
    4.  **Бескрайняя настройка через свойства и события.**

**7. Реализовали ли вы проекты с многооконным интерфейсом в Windows Forms?**

*   **Да, стандартные подходы:**
    *   **MDI (Multiple Document Interface):** Родительская форма (`IsMdiContainer = true`) и дочерние (`MdiParent = this`).
    *   **SDI (Single Document Interface) с плавающими окнами:** Использование `DockPanel` Suite от DevExpress или стандартного `Form` с `FormBorderStyle = SizableToolWindow`.

**8. Дайте определение понятия DataBinding и расскажите, как оно применяется в WinForms.**

*   **DataBinding** — это автоматическое отображение данных из источника (объект, коллекция, БД) в свойства элементов управления и синхронизация изменений.
*   **Применение:**
    *   **Простая привязка:** `textBox1.DataBindings.Add("Text", myObject, "PropertyName");`
    *   **Сложная привязка:** Использование компонента `BindingSource` как прокси между данными и контролами. `bindingSource.DataSource = myList; dataGridView1.DataSource = bindingSource;`

**9. Что означает термин "layout manager" и зачем он нужен?**

*   **Layout Manager** — это компонент, который автоматически управляет размером и позицией дочерних контролов на форме.
*   **Зачем нужен:** Для создания интерфейсов, которые корректно масштабируются и выглядят при изменении размера формы или шрифтов. Избавляет от жесткой фиксации координат (`Top`, `Left`).

**10. Приведите пример ситуации, когда вы использовали BindingSource для связывания данных.**

*   **Сценарий:** Форма для редактирования клиента с несколькими текстовыми полями и `DataGridView` для списка его заказов.
*   **Реализация:**
    1.  Создать два `BindingSource`: `bsCustomer` и `bsOrders`.
    2.  `bsCustomer.DataSource = customer;` (один объект)
    3.  `bsOrders.DataSource = bsCustomer; bsOrders.DataMember = "Orders";` (дочерняя коллекция)
    4.  Привязать `textBoxName.DataBindings.Add("Text", bsCustomer, "Name");`
    5.  Привязать `dataGridViewOrders.DataSource = bsOrders;`
    *   **Преимущество:** `BindingSource` автоматически синхронизирует валютный менеджер (текущую позицию) и обеспечивает навигацию (`MoveNext`, `MovePrevious`).

---

### **ADO.NET**

**1. Поясните назначение SqlConnection, SqlCommand и SqlDataReader.**

*   **SqlConnection:** Представляет уникальное соединение с базой данных. Управляет открытием (`Open()`) и закрытием (`Close()`) сессии.
*   **SqlCommand:** Представляет SQL-запрос или хранимую процедуру, которая выполняется в базе данных. Использует соединение SqlConnection.
*   **SqlDataReader:** Предоставляет высокопроизводительный способ чтения данных в режиме "только вперед" (forward-only) из источника данных. Данные не загружаются в память полностью, а читаются потоком.

**2. Как выполняется обработка ошибок в ADO.NET?**

Ошибки обрабатываются с помощью блоков `try-catch`. ADO.NET генерирует специфические исключения типа `SqlException`, которые содержат детальную информацию.
```csharp
try
{
    // ... операции с БД
}
catch (SqlException ex)
{
    foreach (SqlError error in ex.Errors)
    {
        Console.WriteLine($"Error #{error.Number}: {error.Message}");
    }
}
catch (Exception ex)
{
    // Обработка других исключений
}
```

**3. Какие виды команд поддерживаются в ADO.NET (SqlCommand)?**

*   **Text:** Стандартный SQL-запрос. (`CommandType.Text`)
*   **StoredProcedure:** Вызов хранимой процедуры. (`CommandType.StoredProcedure`)
*   **TableDirect:** (В основном для OLE DB) Возвращает все строки таблицы.

**4. Опишите работу механизма TransactionScope и зачем он нужен.**

`TransactionScope` позволяет определить блок кода, который участвует в транзакции. Он поддерживает распределенные транзакции (между разными базами данных или ресурсами).
```csharp
using (var scope = new TransactionScope())
{
    using (var conn1 = new SqlConnection(connString1))
    {
        conn1.Open();
        // Выполнить команды в первой БД
    }
    using (var conn2 = new SqlConnection(connString2))
    {
        conn2.Open();
        // Выполнить команды во второй БД
    }
    // Если все операции успешны, фиксируем транзакцию
    scope.Complete();
} // Если Complete() не вызван, транзакция автоматически откатывается
```

**5. В чём отличие синхронного и асинхронного подхода в работе с базой данных через ADO.NET?**

*   **Синхронный:** Поток приложения блокируется до завершения операции с БД. Может привести к "зависанию" UI.
*   **Асинхронный:** Поток не блокируется. Используются методы с суффиксом `Async` (`ExecuteReaderAsync`, `ExecuteNonQueryAsync`) и ключевые слова `async`/`await`. Позволяет эффективно использовать ресурсы, особенно в UI-приложениях и веб-сервисах.

**6. Какова роль объекта DbParameter и почему его важно использовать?**

`DbParameter` (и его конкретные реализации, как `SqlParameter`) представляет параметр для команды.
*   **Безопасность:** Это единственный правильный способ подстановки значений в запрос. Полностью защищает от SQL-инъекций.
*   **Производительность:** Позволяет СУБД кэшировать и повторно использовать план выполнения для одного и того же запроса с разными параметрами.
*   **Типобезопасность:** Параметры являются строго типизированными.

**7. Какие ограничения производительности возможны при использовании хранимых процедур?**

*   **Неправильные планы выполнения:** План выполнения может быть закэширован для неоптимальных параметров (Parameter Sniffing).
*   **Слишком сложная логика:** Очень сложные процедуры могут тяжело поддаваться оптимизации.
*   **Избыточные операции:** Необязательные временные таблицы, курсоры.
*   **Проблемы масштабирования:** Распределение логики между приложением и БД может усложнить горизонтальное масштабирование.

**8. Вы знаете способы защиты от SQL-инъекций в ADO.NET?**

1.  **Использование параметризованных запросов (DbParameter)** — основной и самый важный метод.
2.  **Проверка и санитизация входных данных** на уровне приложения.
3.  **Принцип наименьших привилегий:** Запуск приложения от имени пользователя БД с минимально необходимыми правами (только на выполнение конкретных хранимых процедур, без прямого доступа к таблицам).
4.  **Использование ORM** (например, Entity Framework), которые по умолчанию используют параметризованные запросы.

**9. Опишите процесс исполнения пакетных операций с использованием BulkCopy.**

`SqlBulkCopy` позволяет эффективно загружать большие объемы данных в таблицу SQL Server.
```csharp
using (var bulkCopy = new SqlBulkCopy(connectionString))
{
    bulkCopy.DestinationTableName = "MyTable";
    bulkCopy.WriteToServer(dataTable); // или IDataReader
}
```
Это значительно быстрее, чем последовательные `INSERT`.

**10. Можно ли переиспользовать один объект соединения между несколькими потоками приложения?**

**Нет.** Объекты `SqlConnection` не являются потокобезопасными. Создавайте и используйте соединение в рамках одного потока. Для многопоточных приложений используйте пул соединений (Connection Pooling), который включен по умолчанию в ADO.NET. Каждый поток запрашивает свое собственное соединение из пула.

---

### **JSON/XML/XSLT/CSS/HTML**

**1. Различия между XML и JSON форматом данных?**

| Характеристика | XML | JSON |
| :--- | :--- | :--- |
| **Полнота** | Язык разметки, можно описывать документы | Формат обмена данными |
| **Теги** | Использует теги (открывающие/закрывающие) | Использует пары "ключ-значение" |
| **Размер** | Более многословный, больше избыточности | Более компактный |
| **Парсинг** | Сложнее, требует XML-парсера (DOM, SAX) | Проще, парсится в объект JavaScript |
| **Типы данных** | Нет встроенной поддержки типов | Есть встроенные типы (строка, число, булев, массив, объект, null) |
| **Читаемость** | Средняя для человека | Высокая |

**2. Что такое XSLT и как его применять?**

*   **XSLT (eXtensible Stylesheet Language Transformations):** Язык для преобразования XML-документов в другие форматы (XML, HTML, текст).
*   **Применение:** Пишется XSLT-таблица (stylesheet), которая применяется к XML-документу с помощью XSLT-процессора. Результат — преобразованный документ.

**3. Объясните понятие AJAX и как оно связано с JSON?**

*   **AJAX (Asynchronous JavaScript and XML):** Техника создания интерактивных веб-приложений, позволяющая обмениваться данными с сервером без перезагрузки страницы.
*   **Связь с JSON:** Изначально в AJAX использовался XML, но сегодня JSON стал стандартом де-факто для передачи данных из-за своей легкости и простоты интеграции с JavaScript.

**4. Могли бы рассказать о принципах кроссбраузерной совместимости CSS-стилей?**

1.  **Reset/Normalize CSS:** Использование сброса стилей для устранения различий в стандартных стилях браузеров.
2.  **Вендорные префиксы:** Использование `-webkit-`, `-moz-`, `-ms-` для экспериментальных свойств.
3.  **Постепенная деградация (Graceful Degradation):** Сайт работает в старых браузерах, но с меньшим функционалом.
4.  **Прогрессивное улучшение (Progressive Enhancement):** Сначала базовая функциональность, затем улучшения для современных браузеров.
5.  **Тестирование:** Постоянное тестирование в разных браузерах и на разных устройствах.

**5. Какие инструменты вы используете для проверки валидности HTML-кода?**

*   **Онлайн-валидаторы W3C.**
*   **Инструменты разработчика в браузерах** (Chrome DevTools, Firefox Developer Tools).
*   **Плагины для IDE/редакторов** (например, для VS Code).

**6. Обсудите различие подходов структурирования данных в JSON и XML.**

*   **JSON:** Иерархия строится на объектах (`{}`) и массивах (`[]`). Более простая и плоская структура, ориентированная на данные.
*   **XML:** Иерархия строится на вложенных элементах. Может содержать атрибуты, пространства имен, типы данных в DTD/XSD. Более строгая и сложная структура, подходит для документов.

**7. Может ли одно свойство CSS повлиять сразу на несколько селекторов одновременно?**

**Да.** Можно перечислить несколько селекторов через запятую.
```css
h1, h2, .my-class, #my-id {
    color: blue;
    font-family: Arial;
}
```

**8. Что такое Flexbox и как он помогает создавать адаптивные веб-интерфейсы?**

**Flexbox** — это CSS3 модуль для создания гибких и эффективных макетов. Он упрощает выравнивание, распределение пространства и порядок элементов внутри контейнера, даже если их размер неизвестен или динамичен.
*   **Помощь в адаптивности:** Легко менять направление (`flex-direction`), переносить строки (`flex-wrap`), изменять порядок элементов (`order`) и выравнивание для разных размеров экрана.

**9. Расскажите о механизме стилизации текста с помощью псевдоклассов :hover и :active.**

*   **`:hover`:** Применяет стиль, когда пользователь наводит курсор на элемент (но не активирует его).
*   **`:active`:** Применяет стиль в момент активации элемента (например, нажатие кнопки мыши на ссылке).
```css
a { color: blue; }
a:hover { color: darkblue; } /* При наведении */
a:active { color: red; } /* В момент клика */
```

**10. Объясните концепцию серверных обработчиков (Handler), используемых для динамической генерации XML-документов.**

*   **HTTP Handler (обработчик):** Компонент в ASP.NET, который обрабатывает HTTP-запросы к определенным расширениям или URL.
*   **Генерация XML:** Можно создать кастомный handler (реализующий `IHttpHandler`), который будет:
    1.  Устанавливать `Content-Type: text/xml`.
    2.  Динамически формировать XML-документ (например, с помощью `XmlWriter` или сериализации объекта).
    3.  Записывать этот XML в поток ответа (`context.Response.OutputStream`).

---

### **Python**

**1. Зачем используют виртуальные окружения в Python?**

Для изоляции зависимостей проекта. Позволяют иметь разные версии библиотек для разных проектов, избегая конфликтов. Инструменты: `venv` (встроенный), `virtualenv`, `pipenv`, `poetry`.

**2. Объясните, как работают декораторы функций в Python.**

Декоратор — это функция, которая принимает другую функцию и расширяет её функциональность, не меняя её код.
```python
def my_decorator(func):
    def wrapper():
        print("Что-то происходит до вызова функции.")
        func()
        print("Что-то происходит после вызова функции.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello() # Вызовет wrapper(), который вызовет say_hello() с доп. логикой
```

**3. В чём состоит особенность понимания списка (list comprehension)?**

Это компактный способ создания списков.
```python
# Вместо этого:
squares = []
for x in range(10):
    squares.append(x**2)

# Можно написать так:
squares = [x**2 for x in range(10)]
```
Может включать условие: `[x for x in range(10) if x % 2 == 0]`.

**4. Что такое замыкания (closures) в Python?**

Замыкание — это функция, которая запоминает значения из охватывающей её области видимости, даже после того, как внешняя функция завершила работу.
```python
def make_multiplier(x):
    def multiplier(n):
        return x * n
    return multiplier

times3 = make_multiplier(3)
print(times3(9)) # Выведет 27
# Внутренняя функция multiplier помнит, что x = 3.
```

**5. Можете объяснить концепцию async/await в Python?**

Это способ написания асинхронного кода для задач, связанных с I/O (сеть, файлы). Позволяет приостанавливать выполнение функции, пока она ждет результата, и в это время выполнять другие функции.
*   `async def`: Объявляет асинхронную функцию (корутину).
*   `await`: Приостанавливает выполнение корутины до завершения другой асинхронной операции.
```python
import asyncio

async def fetch_data():
    print("Start fetching")
    await asyncio.sleep(2) # Имитация долгого I/O-запроса
    print("Done fetching")
    return {'data': 1}

async def main():
    task = asyncio.create_task(fetch_data())
    # Пока fetch_data "спит", можно делать что-то еще
    print("Doing other work...")
    # Ждем результат
    result = await task
    print(result)

asyncio.run(main())
```

**6. Отличаются ли классы в Python от классов в C#, если да — то чем именно?**

*   **Да, отличаются.**
    *   **Наследование:** Python поддерживает множественное наследование, C# — только одиночное.
    *   **Модификаторы доступа:** C# имеет `public`, `private`, `protected`, `internal`. В Python всё "public", но есть соглашения: `_protected`, `__private` (name mangling).
    *   **Методы и поля:** В C# их объявление строгое. В Python они могут быть добавлены динамически в любой момент.
    *   **Интерфейсы:** В C# есть явное понятие интерфейса. В Python — это неявный контракт ("утиная типизация").
    *   **Свойства (Properties):** В C# — `get; set;`. В Python — используются декораторы `@property`, `@name.setter`.

**7. Покажите, как реализуется простая реализация Singleton паттерна в Python.**

Через переопределение метода `__new__`:
```python
class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance

obj1 = Singleton()
obj2 = Singleton()
print(obj1 is obj2) # Выведет True
```
*Более питоновский способ — использование модулей (модуль в Python является синглтоном по своей природе).*

**8. Какие бывают встроенные структуры данных в Python и их основное применение?**

*   **`list`:** Упорядоченная, изменяемая коллекция. Для хранения последовательностей.
*   **`tuple`:** Упорядоченная, *неизменяемая* коллекция. Для константных данных.
*   **`dict`:** Неупорядоченная (до Python 3.7+ упорядоченная) коллекция пар ключ-значение. Для поиска по ключу.
*   **`set`:** Неупорядоченная коллекция *уникальных* элементов. Для проверки принадлежности и операций над множествами.
*   **`str`:** Неизменяемая последовательность символов.

**9. Когда лучше использовать многопоточность, а когда многопроцессность в Python?**

*   **Многопоточность (threading):** Подходит для задач, связанных с *I/O* (ожидание сети, диска). Из-за GIL (Global Interpreter Lock) потоки в Python не выполняют CPU-код параллельно, но при I/O GIL отпускается.
*   **Многопроцессность (multiprocessing):** Подходит для задач, связанных с *CPU* (тяжелые вычисления). Каждый процесс имеет свой интерпретатор и память, что позволяет обойти GIL и использовать несколько ядер CPU.

**10. Чем различаются set и frozenset в Python?**

*   **`set`:** Изменяемое множество. Можно добавлять и удалять элементы.
*   **`frozenset`:** Неизменяемое множество. Не может быть изменено после создания. Является хешируемым, поэтому может быть элементом другого `set` или ключом словаря `dict`.

---

### **Git**

**1. Как создать ветку в Git и объединить изменения обратно в основную ветвь?**

```bash
# Создание и переход на новую ветку
git checkout -b feature-branch

# ... работа, коммиты ...

# Переключение на основную ветку (например, main)
git checkout main

# Слияние feature-branch в main
git merge feature-branch
```

**2. Как вернуть удалённый файл из репозитория Git?**

Найти коммит, в котором файл еще существовал, и восстановить его:
```bash
# Найти коммит, где файл был удален
git log -- path/to/file

# Восстановить файл из этого коммита
git checkout <commit-hash>^ -- path/to/file
# Или, если удаление было в последнем коммите:
git checkout HEAD^ -- path/to/file
```
Затем сделать коммит.

**3. Что значит команда git reset HEAD^?**

*   `git reset HEAD^` (без флагов) — это `--mixed` по умолчанию.
    *   Она перемещает указатель текущей ветки на коммит назад (`HEAD^` — предыдущий коммит).
    *   Изменения из отмененного коммита перемещаются в **рабочую директорию** как неиндексированные.
*   `git reset --soft HEAD^` — изменения помещаются в **staging area** (индексированы).
*   `git reset --hard HEAD^` — изменения **полностью удаляются** (и из индекса, и из рабочей директории). Опасно!

**4. Как разрешить конфликт слияния двух ветвей?**

1.  Git сообщит о конфликте в файлах.
2.  Открыть файлы с конфликтами. Они будут содержать маркеры (`<<<<<<<`, `=======`, `>>>>>>>`).
3.  **Вручную** отредактировать файлы, оставив нужный код и убрав маркеры.
4.  Проиндексировать исправленные файлы: `git add <file-name>`.
5.  Зафиксировать слияние: `git commit`.

**5. Каково значение флага --force в команде push?**

`git push --force` перезаписывает историю на удаленном репозитории вашей локальной историей. **Опасная операция**, так как может удалить коммиты других разработчиков. Более безопасная альтернатива — `--force-with-lease`, которая проверяет, что удаленная ветка не изменилась с момента вашего последнего fetch.

**6. Чем отличаются команды rebase и merge?**

*   **`merge`:** Создает новый коммит слияния, который объединяет истории двух веток. Сохраняет полную историю, включая все ветвления.
*   **`rebase`:** "Перемещает" всю ветку на верх другой ветки, переписывая историю. Создает линейную историю, но изменяет хеши коммитов. **Нельзя использовать на публичных ветках.**

**7. Знаете ли вы, как настроить SSH ключи для авторизации в GitHub/GitLab?**

1.  Сгенерировать пару ключей: `ssh-keygen -t ed25519 -C "your_email@example.com"`
2.  Скопировать содержимое *публичного* ключа (`~/.ssh/id_ed25519.pub`).
3.  Вставить ключ в настройках аккаунта на GitHub/GitLab.

**8. В каком порядке применяются хуки pre-commit и post-receive?**

*   **pre-commit:** Срабатывает на *локальной* машине *до* создания коммита.
*   **post-receive:** Срабатывает на *удаленном* сервере *после* того, как в него были отправлены (push) изменения.

**9. Назовите плюсы и минусы использования субмодулей (submodules) в Git.**

*   **Плюсы:** Позволяют включить другой репозиторий как поддиректорию. Полезно для зависимостей.
*   **Минусы:** Сложность управления (нужно делать отдельные коммиты для субмодуля). Легко получить рассинхронизацию. Новые разработчики должны использовать `git clone --recurse-submodules`.

**10. Что делать, если возникла ошибка push due to non-fast forward commit?**

Ошибка означает, что в удаленном репозитории есть коммиты, которых нет у вас локально.
**Решение:**
1.  Сначала выполнить `git pull` (или `git fetch` + `git merge`/`git rebase`), чтобы получить изменения с удаленного сервера.
2.  Разрешить возможные конфликты.
3.  Затем выполнить `git push`.

---

### **Scrum**

**1. Что такое спринт и ретроспектива в Scrum?**

*   **Спринт:** Фиксированный по времени итерация (обычно 1-4 недели), в течение которой создается готовый к релизу инкремент продукта.
*   **Ретроспектива (Sprint Retrospective):** Встреча в конце спринта, где команда обсуждает, что прошло хорошо, что можно улучшить, и формулирует план улучшений на следующий спринт.

**2. Какие роли определены в методологии Scrum?**

*   **Владелец Продукта (Product Owner):** Определяет "Что" делать, управляет Product Backlog.
*   **Scrum Master:** "Как" делать, обеспечивает понимание и соблюдение Scrum, устраняет препятствия.
*   **Команда Разработчиков (Development Team):** Перекрестно-функциональная группа, которая создает инкремент продукта.

**3. Расскажите подробнее о Daily Scrum встрече.**

Ежедневная 15-минутная встреча для синхронизации команды. Каждый участник отвечает на три вопроса:
1.  Что я сделал вчера, чтобы помочь команде достичь цели спринта?
2.  Что я сделаю сегодня?
3.  Вижу ли я какие-либо препятствия?

**4. По каким критериям оценивается успешность спринта?**

*   **Выполнение условий Готовности (Definition of Done).**
*   **Достижение Цели Спринта (Sprint Goal).**
*   **Количество выполненных задач из Sprint Backlog** (хотя это вторичный показатель).

**5. Какие техники оценки задач применяются в Scrum?**

*   **Планирование покера (Planning Poker):** Использование стори поинтов (Story Points) и последовательности Фибоначчи (1, 2, 3, 5, 8, 13...).
*   **Сравнение (Comparison):** Сравнение новой задачи с уже оцененными.
*   **T-Shirt Sizes:** Оценка размера задач как XS, S, M, L, XL.

**6. Чему служит Product Backlog?**

Это приоритизированный список всей функциональности, исправлений, улучшений и задач, которые могут понадобиться в продукте. Это единственный источник требований для любой работы над продуктом.

**7. Возможно ли вносить изменения в требования внутри одного спринта?**

**Как правило, нет.** Цель спринта фиксирована, и команда должна быть ограждена от изменений в течение спринта, чтобы сосредоточиться. Владелец продукта может вносить изменения в Product Backlog, но не в текущий Sprint Backlog. Исключения — крайние случаи, по согласованию с командой.

**8. Как часто рекомендуется проводить демо результатов (Sprint Review)?**

В конце каждого спринта.

**9. Что такое Definition of Done (DoD)?**

Это четкий, разделяемый всеми список критериев, которые должны быть выполнены, чтобы задача или инкремент продукта считались завершенными. Например: "Код написан, протестирован, прошел ревью, интегрирован, документация обновлена".

**10. Расскажите о процессе планирования продукта (Product Planning Meeting).**

Это встреча, на которой Владелец Продукта и команда обсуждают долгосрочное видение продукта, определяют основные вехи и корректируют дорожную карту (Roadmap). Она не привязана жестко к одному спринту и фокусируется на стратегических целях.

---

### **Практические задания**

**Задание №1: SQL-запрос с индексированием**

```sql
-- Запрос
SELECT *
FROM users
WHERE name LIKE 'И%' AND city = 'Москва';

-- Рекомендуемые индексы для ускорения:
-- Составной индекс для покрывающего запроса (Covering Index)
CREATE INDEX idx_users_city_name ON users(city, name);

-- Или, в зависимости от селективности, можно создать два отдельных индекса:
-- CREATE INDEX idx_users_name ON users(name);
-- CREATE INDEX idx_users_city ON users(city);
-- Но составной индекс, как правило, эффективнее для такого условия.
```

**Задание №2: Простой WinForms интерфейс**

```csharp
using System;
using System.Windows.Forms;

namespace SimpleWinFormsApp
{
    public partial class MainForm : Form
    {
        private TextBox textBoxInput;
        private Button buttonShow;
        private Button buttonClear;

        public MainForm()
        {
            InitializeComponent();
        }

        private void InitializeComponent()
        {
            this.textBoxInput = new TextBox();
            this.buttonShow = new Button();
            this.buttonClear = new Button();

            // TextBox
            this.textBoxInput.Location = new System.Drawing.Point(12, 12);
            this.textBoxInput.Size = new System.Drawing.Size(260, 20);

            // Button Show
            this.buttonShow.Location = new System.Drawing.Point(12, 38);
            this.buttonShow.Size = new System.Drawing.Size(125, 23);
            this.buttonShow.Text = "Показать";
            this.buttonShow.Click += new EventHandler(this.ButtonShow_Click);

            // Button Clear
            this.buttonClear.Location = new System.Drawing.Point(147, 38);
            this.buttonClear.Size = new System.Drawing.Size(125, 23);
            this.buttonClear.Text = "Очистить";
            this.buttonClear.Click += new EventHandler(this.ButtonClear_Click);

            // Form
            this.ClientSize = new System.Drawing.Size(284, 71);
            this.Controls.Add(this.textBoxInput);
            this.Controls.Add(this.buttonShow);
            this.Controls.Add(this.buttonClear);
            this.Text = "Простое приложение";
        }

        private void ButtonShow_Click(object sender, EventArgs e)
        {
            MessageBox.Show(this.textBoxInput.Text, "Введенное значение");
        }

        private void ButtonClear_Click(object sender, EventArgs e)
        {
            this.textBoxInput.Clear();
        }
    }

    public class Program
    {
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainForm());
        }
    }
}
```

**Задание №3: Десериализация JSON в C#**

```csharp
using System;
using System.Text.Json;

public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

class Program
{
    static void Main()
    {
        string jsonString = "{\"Name\": \"Иван\", \"Age\": 30}";

        try
        {
            Person person = JsonSerializer.Deserialize<Person>(jsonString);

            Console.WriteLine($"Имя: {person.Name}");
            Console.WriteLine($"Возраст: {person.Age}");
        }
        catch (JsonException ex)
        {
            Console.WriteLine($"Ошибка десериализации JSON: {ex.Message}");
        }
    }
}
```

**Задание №4: Вставка в PostgreSQL с помощью ADO.NET**

```csharp
using System;
using Npgsql; // Требуется NuGet пакет Npgsql

class Program
{
    static void Main()
    {
        string connectionString = "Host=myserver;Username=user;Password=pass;Database=mydb";

        using (var connection = new NpgsqlConnection(connectionString))
        {
            try
            {
                connection.Open();

                string sql = "INSERT INTO users (name, email) VALUES (@name, @email)";
                using (var command = new NpgsqlCommand(sql, connection))
                {
                    command.Parameters.AddWithValue("name", "Иван Иванов");
                    command.Parameters.AddWithValue("email", "ivan@mail.ru");

                    int rowsAffected = command.ExecuteNonQuery();
                    Console.WriteLine($"Вставлено строк: {rowsAffected}");
                }
            }
            catch (NpgsqlException ex)
            {
                Console.WriteLine($"Ошибка базы данных: {ex.Message}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Общая ошибка: {ex.Message}");
            }
        }
    }
}
```

**Задание №5: Python-скрипт с virtualenv и requests**

```bash
# В командной строке (bash/cmd):
# 1. Создать виртуальное окружение
python -m venv myenv

# 2. Активировать его
# Linux/macOS:
source myenv/bin/activate
# Windows:
# myenv\Scripts\activate

# 3. Установить библиотеку requests
pip install requests
```

```python
# script.py
import requests

def main():
    url = "https://api.github.com"
    
    try:
        response = requests.get(url)
        # Выводим статус-код ответа
        print(f"Статус-код ответа: {response.status_code}")
        
        # Можно также вывести часть заголовков для информации
        print("Заголовки ответа:")
        for key, value in response.headers.items():
            print(f"  {key}: {value}")
            
    except requests.exceptions.RequestException as e:
        print(f"Произошла ошибка при запросе: {e}")

if __name__ == "__main__":
    main()
```

```bash
# 4. Запустить скрипт
python script.py
```