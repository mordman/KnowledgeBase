**Правильный подход — это структурированная диагностика, а не случайные догадки.**

**Шаг 0: Понимание контекста и сбор информации.**
Прежде чем смотреть план, нужно понять:
1.  **Что делает запрос?** Какова его бизнес-логика? Можно ли её упростить?
2.  **Контекст вызова:** Как часто он выполняется? Каковы volume данных (строки на входе/выходе)? Есть ли пессимизирующие bind-переменные?
3.  **Сбор объективной информации:**
    ```sql
    -- Объём данных и статистика
    SELECT table_name, num_rows, blocks FROM user_tables WHERE table_name IN ('TAB1', 'TAB2');
    SELECT index_name, uniqueness, clustering_factor FROM user_indexes WHERE table_name = 'TAB1';
    -- Последний сбор статистики
    SELECT last_analyzed FROM user_tables WHERE table_name = 'TAB1';
    ```

**Шаг 1: Анализ плана выполнения (`EXPLAIN PLAN`).**
Недостаточно просто «просмотреть план». Нужно его **прочитать и интерпретировать**.
```sql
-- Генерация плана
EXPLAIN PLAN FOR
SELECT /*+ YOUR_HINT */ ... ваш медленный запрос ...;

-- Просмотр с ключевыми метриками (DBMS_XPLAN)
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(FORMAT => 'ALLSTATS LAST +COST +BYTES +OUTLINE'));
```
**На что смотреть в первую очередь:**
*   **Операция с наибольшим `Cost` (стоимость).**
*   **Операция с наибольшим `A-Rows` (реальное число строк) vs `E-Rows` (ожидаемое число строк).** Если разница велика (на порядок) — это прямой сигнал о **некорректной статистике** или неверной оценке кардинальности. Это главная причина неоптимальных планов.
*   **Тип доступа (ACCESS):**
    *   `TABLE ACCESS FULL` — сканирование всей таблицы. Требует проверки: нет подходящего индекса? Индекс не используется из-за функции в `WHERE`?
    *   `INDEX RANGE SCAN` — хорошо. `INDEX FULL SCAN` — может быть тяжело для больших индексов.
    *   `INDEX SKIP SCAN` — часто признак, что составной индекс используется не с первого столбца.
*   **Тип соединения (JOIN):**
    *   `HASH JOIN` — обычно оптимален для больших несортированных наборов.
    *   `NESTED LOOPS` — хорош, если один набор очень мал (driving set) и для второго есть уникальный индекс.
    *   `MERGE JOIN` — хорош для уже отсортированных данных.
    *   **Неверный выбор типа соединения** часто следствие плохой статистики.

**Шаг 2: Анализ фактического выполнения (`SQL Monitor` / `Active Session History`).**
План — это предположение оптимизатора. Нам нужны **факты**.
```sql
-- Для запроса, выполняющегося прямо сейчас (требуется Tuning Pack)
SELECT sql_id, sql_exec_id FROM v$session WHERE sql_id = '...';

-- Детальный отчёт (DBMS_SQLTUNE.REPORT_SQL_MONITOR) - показывает реальные метрики в runtime:
-- Время по операциям, число строк, использование памяти/диска для hash-join/sort, ожидания (wait events).
```
**Ключевые метрики:** `CPU`, `I/O` (дисковый), `Wait Events` (`db file sequential/scattered read` — чтение индекса/таблицы, `direct path read temp` — чтение временных данных с диска).

**Шаг 3: Целенаправленная оптимизация (на основе диагностики).**

**A) Если проблема в статистике:**
```sql
-- Сбор свежей статистики с увеличенной выборкой
BEGIN
    DBMS_STATS.GATHER_TABLE_STATS(
        ownname => 'SCHEMA',
        tabname => 'BIG_TABLE',
        estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
        method_opt => 'FOR ALL COLUMNS SIZE SKEWONLY', -- важно для колонок с skewed data
        cascade => TRUE
    );
END;
/
-- Возможно, нужно собрать гистограммы на колонки, используемые в неравенствах или `WHERE col = :bind`.
```

**B) Если проблема в доступе (лишние FULL SCAN):**
*   **Создание индекса:** Не просто «добавить индекс», а **правильного**.
    ```sql
    -- Индекс для JOIN и WHERE
    CREATE INDEX idx_fk_dept ON employees(department_id, hire_date) COMPUTE STATISTICS;
    -- Покрывающий индекс (covering index) для запросов, выбирающих несколько полей
    CREATE INDEX idx_cov ON orders(order_date, customer_id, status) COMPUTE STATISTICS;
    ```
*   **Переписывание запроса:** Убрать функции с колонок (`WHERE UPPER(name) = ...`), использовать `WITH` для материализации промежуточных результатов, разделить один сложный запрос на несколько.

**C) Если проблема в соединениях и агрегации:**
*   **Использование хинтов как последнее средство:** Только если вы доказали, что оптимизатор ошибается, и зафиксировали это.
    ```sql
    SELECT /*+ LEADING(e) USE_NL(d) */ ... -- Ведущая таблица e, соединение вложенными циклами с d
    SELECT /*+ PARALLEL(t, 4) */ ...        -- Принудительный параллелизм
    ```
*   **Оптимизация работы с памятью:** Увеличение `PGA_AGGREGATE_TARGET` для операций `HASH JOIN` и `SORT`, чтобы они выполнялись в памяти, а не на диск (`temp` tablespace).

**Шаг 4: Верификация.**
После любых изменений (статистика, индекс, переписывание) **обязательно**:
1.  Сравнить новые и старые планы.
2.  Измерить реальное время выполнения на production-like данных.
3.  Проверить, что изменения не сломали другие запросы.