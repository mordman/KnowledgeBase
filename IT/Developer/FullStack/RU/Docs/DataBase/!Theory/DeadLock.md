### **Что такое Deadlock (Взаимоблокировка) в базе данных?**
**Deadlock** (взаимоблокировка) — это ситуация, когда две или более транзакций блокируют друг друга, ожидая освобождения ресурсов, удерживаемых другой транзакцией. В результате ни одна из транзакций не может продолжить выполнение, и система "зависает".

---

### **Пример Deadlock**
Представьте две транзакции:

| **Транзакция 1**               | **Транзакция 2**               |
|--------------------------------|--------------------------------|
| 1. Блокирует **строку A**      | 1. Блокирует **строку B**      |
| 2. Пытается заблокировать **B**| 2. Пытается заблокировать **A**|
| → Ожидает освобождения **B**   | → Ожидает освобождения **A**   |

Обе транзакции зависли, так как каждая ждет ресурс, удерживаемый другой.

---

### **Как избежать Deadlock?**

#### **1. Избегание условий возникновения Deadlock**
Deadlock возникает при одновременном выполнении **четырёх условий** (по Кофману):
- **Взаимное исключение** (Mutual Exclusion): Ресурс может принадлежать только одной транзакции.
- **Удержание и ожидание** (Hold and Wait): Транзакция удерживает ресурс и ждет другой.
- **Невозможность отнятия ресурса** (No Preemption): Ресурс нельзя принудительно отнять.
- **Циклическое ожидание** (Circular Wait): Цепочка транзакций, ожидающих друг друга.

**Решение:** Устраните хотя бы одно из условий.

---

#### **2. Практические методы предотвращения**

##### **А. Порядок блокировки ресурсов**
- **Всегда блокируйте ресурсы в одном и том же порядке** (например, сначала по возрастанию ID).
- Пример:
  ```sql
  -- Транзакция 1 и Транзакция 2 блокируют сначала A, потом B (или наоборот), но не вразнобой.
  ```

##### **Б. Уменьшение времени удержания блокировок**
- **Сокращайте длительность транзакций** (быстро фиксируйте или откатывайте).
- Избегайте долгих операций внутри транзакций (например, запросов к внешним API).

##### **В. Использование оптимистичной блокировки**
- Вместо пессимистичной блокировки (LOCK) используйте **версионность данных** (например, поле `version`).
- Пример:
  ```sql
  UPDATE accounts SET balance = 100, version = 2 WHERE id = 1 AND version = 1;
  ```
  Если `version` изменился, транзакция откатывается.

##### **Г. Разделение транзакций на более мелкие**
- Разбивайте крупные транзакции на несколько мелких.

##### **Д. Использование таймаутов**
- Настройте **таймаут ожидания блокировки** (например, в MS SQL: `SET LOCK_TIMEOUT 5000;`).
- Если блокировка не получена за указанное время, транзакция откатывается.

##### **Е. Мониторинг и автоматическое разрешение**
- В большинстве СУБД (PostgreSQL, MS SQL) есть механизмы **автоматического обнаружения и разрыва deadlock**.
- Пример для PostgreSQL:
  ```sql
  -- Логирование deadlock в журнале:
  log_lock_waits = on
  deadlock_timeout = 1s
  ```

---

#### **3. Как СУБД разрешают Deadlock?**
- **Автоматический откат одной из транзакций** (обычно той, которая меньше сделала изменений).
- **Уведомление приложения** (например, в PostgreSQL выбрасывается ошибка `ERROR: deadlock detected`).
- Приложение должно **повторить транзакцию** после получения такой ошибки.

---

### **Пример кода для обработки Deadlock (на Python с SQLAlchemy)**
```python
from sqlalchemy import exc
from sqlalchemy.orm import sessionmaker

Session = sessionmaker(bind=engine)
session = Session()

while True:
    try:
        # Выполнение транзакции
        session.execute("UPDATE accounts SET balance = balance - 100 WHERE id = 1")
        session.execute("UPDATE accounts SET balance = balance + 100 WHERE id = 2")
        session.commit()
        break
    except exc.IntegrityError as e:
        session.rollback()
        print("Deadlock detected, retrying...")
        continue
```

---

### **Вывод**
- **Deadlock** — это блокировка, которую сложно полностью избежать, но можно минимизировать.
- **Ключевые методы:** порядок блокировок, сокращение времени транзакций, оптимистичная блокировка, таймауты.
- **СУБД помогают:** автоматически обнаруживают и разрывают deadlock, но приложение должно быть готово к повторению транзакции.