Принцип **ACID** — это набор свойств, которые гарантируют надежность транзакций в базах данных, особенно в реляционных системах. Каждая буква в аббревиатуре обозначает ключевое свойство:

---

### 1. **Atomicity (Атомарность)**


## Оглавление
  - [1. **Atomicity (Атомарность)**](#1-atomicity-атомарность)
  - [2. **Consistency (Согласованность)**](#2-consistency-согласованность)
  - [3. **Isolation (Изолированность)**](#3-isolation-изолированность)
  - [4. **Durability (Устойчивость)**](#4-durability-устойчивость)
  - [Пример работы ACID](#пример-работы-acid)
  - [Где применяется ACID?](#где-применяется-acid)
- [**Примеры Race Condition в базе данных**](#примеры-race-condition-в-базе-данных)
  - [**1. Потерянное обновление (Lost Update)**](#1-потерянное-обновление-lost-update)
  - [**2. "Грязное" чтение (Dirty Read)**](#2-грязное-чтение-dirty-read)
  - [**3. Неповторяющееся чтение (Non-Repeatable Read)**](#3-неповторяющееся-чтение-non-repeatable-read)
- [**Как избежать Race Condition в базе данных?**](#как-избежать-race-condition-в-базе-данных)
  - [**1. Использование уровней изоляции транзакций**](#1-использование-уровней-изоляции-транзакций)
  - [**2. Блокировки (Locks)**](#2-блокировки-locks)
  - [**3. Использование атомарных операций**](#3-использование-атомарных-операций)
  - [**4. Применение паттерна "Optimistic Concurrency Control" (OCC)**](#4-применение-паттерна-optimistic-concurrency-control-occ)
  - [**5. Использование хранимых процедур**](#5-использование-хранимых-процедур)
- [**Вывод**](#вывод)
  - [**1. Microsoft SQL Server (MSSQL)**](#1-microsoft-sql-server-mssql)
  - [**2. Oracle**](#2-oracle)
  - [**Дополнительные замечания**](#дополнительные-замечания)

  - [1. **Atomicity (Атомарность)**](#1-atomicity-атомарность)
  - [2. **Consistency (Согласованность)**](#2-consistency-согласованность)
  - [3. **Isolation (Изолированность)**](#3-isolation-изолированность)
  - [4. **Durability (Устойчивость)**](#4-durability-устойчивость)
  - [Пример работы ACID](#пример-работы-acid)
  - [Где применяется ACID?](#где-применяется-acid)
  - [**1. Потерянное обновление (Lost Update)**](#1-потерянное-обновление-lost-update)
  - [**2. "Грязное" чтение (Dirty Read)**](#2-грязное-чтение-dirty-read)
  - [**3. Неповторяющееся чтение (Non-Repeatable Read)**](#3-неповторяющееся-чтение-non-repeatable-read)
  - [**1. Использование уровней изоляции транзакций**](#1-использование-уровней-изоляции-транзакций)
  - [**2. Блокировки (Locks)**](#2-блокировки-locks)
  - [**3. Использование атомарных операций**](#3-использование-атомарных-операций)
  - [**4. Применение паттерна "Optimistic Concurrency Control" (OCC)**](#4-применение-паттерна-optimistic-concurrency-control-occ)
  - [**5. Использование хранимых процедур**](#5-использование-хранимых-процедур)
  - [**1. Microsoft SQL Server (MSSQL)**](#1-microsoft-sql-server-mssql)
  - [**2. Oracle**](#2-oracle)
  - [**Дополнительные замечания**](#дополнительные-замечания)
**Определение:** Транзакция выполняется как единое целое. Либо все операции в транзакции завершаются успешно, либо ни одна из них не применяется.

**Пример:**
Если вы переводите деньги со счета A на счет B, транзакция должна либо полностью завершиться (деньги списаны с A и зачислены на B), либо откатиться (если что-то пошло не так, деньги остаются на A).

**Как обеспечивается:**
Используются механизмы **журналирования** (logs) и **отката** (rollback).

---

### 2. **Consistency (Согласованность)**
**Определение:** Транзакция переводит базу данных из одного согласованного состояния в другое. Все ограничения (например, уникальность ключей, внешние ключи) должны соблюдаться.

**Пример:**
Если в базе есть правило "баланс счета не может быть отрицательным", транзакция не должна допустить списание средств, если это приведет к отрицательному балансу.

**Как обеспечивается:**
Проверка ограничений на уровне базы данных (constraints, triggers).

---

### 3. **Isolation (Изолированность)**
**Определение:** Транзакции выполняются изолированно друг от друга. Промежуточные результаты одной транзакции не видны другим транзакциям до её завершения.

**Проблемы, которые решает:**
- **Грязное чтение** (Dirty Read): Чтение данных, которые ещё не зафиксированы.
- **Неповторяющееся чтение** (Non-Repeatable Read): Повторное чтение одной транзакцией тех же данных дает разные результаты.
- **Фантомное чтение** (Phantom Read): Появление новых строк, соответствующих условию запроса, между двумя чтениями.

**Уровни изоляции:**
- Read Uncommitted
- Read Committed
- Repeatable Read
- Serializable

---

### 4. **Durability (Устойчивость)**
**Определение:** После фиксации транзакции её результаты сохраняются в базе данных даже в случае сбоя (например, отключения питания).

**Как обеспечивается:**
Использование **журналов транзакций** (transaction logs) и механизмов восстановления после сбоев.

---

### Пример работы ACID
Представьте банковскую систему:
1. **Атомарность:** Перевод денег либо полностью завершается, либо отменяется.
2. **Согласованность:** После перевода сумма на обоих счетах остается корректной (например, не появляются "деньги из воздуха").
3. **Изолированность:** Если два клиента одновременно переводят деньги на один счет, их транзакции не мешают друг другу.
4. **Устойчивость:** После подтверждения перевода данные не исчезнут, даже если сервер упадет.

---

### Где применяется ACID?
- **Реляционные базы данных** (PostgreSQL, MS SQL, MySQL) строго соблюдают ACID.
- **NoSQL-базы** (например, MongoDB) могут обеспечивать ACID только на уровне отдельных документов или транзакций (в зависимости от настроек).



## **Примеры Race Condition в базе данных**

### **1. Потерянное обновление (Lost Update)**
Две транзакции одновременно читают и обновляют одну и ту же запись. Одна из транзакций перезаписывает изменения другой.

**Пример:**
- **Транзакция 1** читает баланс счёта (1000 рублей).
- **Транзакция 2** также читает баланс счёта (1000 рублей).
- **Транзакция 1** увеличивает баланс на 100 рублей и записывает 1100 рублей.
- **Транзакция 2** уменьшает баланс на 50 рублей и записывает 950 рублей (перезаписывая результат транзакции 1).

**Результат:** вместо ожидаемых 1050 рублей на счёте остаётся 950 рублей.

---

### **2. "Грязное" чтение (Dirty Read)**
Одна транзакция читает данные, которые ещё не зафиксированы другой транзакцией, а затем эти данные откатываются.

**Пример:**
- **Транзакция 1** списывает 100 рублей со счёта (баланс становится 900 рублей), но ещё не зафиксировала изменения.
- **Транзакция 2** читает баланс (900 рублей) и принимает решение на основе этого значения.
- **Транзакция 1** откатывается, и баланс возвращается к 1000 рублям.
- **Транзакция 2** работает с некорректными данными.

---

### **3. Неповторяющееся чтение (Non-Repeatable Read)**
Одна транзакция читает одни и те же данные дважды, но между чтениями другая транзакция успевает их изменить.

**Пример:**
- **Транзакция 1** читает баланс счёта (1000 рублей).
- **Транзакция 2** списывает 100 рублей и фиксирует изменения (баланс становится 900 рублей).
- **Транзакция 1** снова читает баланс и видит 900 рублей вместо ожидаемых 1000 рублей.

---

## **Как избежать Race Condition в базе данных?**

### **1. Использование уровней изоляции транзакций**
Уровни изоляции определяют, как транзакции взаимодействуют друг с другом. Чем выше уровень изоляции, тем меньше вероятность возникновения Race Condition, но тем ниже производительность.

| Уровень изоляции | Описание | Проблемы, которые решает |
|------------------|----------|--------------------------|
| **Read Uncommitted** | Транзакции видят незафиксированные изменения других транзакций. | — |
| **Read Committed** | Транзакции видят только зафиксированные изменения. | Dirty Read |
| **Repeatable Read** | Транзакция видит одни и те же данные при повторном чтении. | Dirty Read, Non-Repeatable Read |
| **Serializable** | Максимальная изоляция: транзакции выполняются так, как будто они идут последовательно. | Dirty Read, Non-Repeatable Read, Phantom Read |

**Пример для PostgreSQL:**
```sql
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- Ваши SQL-запросы
COMMIT;
```

---

### **2. Блокировки (Locks)**
- **Оптимистичные блокировки:** Используют версии записей. Если версия изменилась с момента чтения, транзакция откатывается.
- **Пессимистичные блокировки:** Явное блокирование строк или таблиц на время выполнения транзакции.

**Пример пессимистичной блокировки в SQL:**
```sql
BEGIN TRANSACTION;
-- Блокируем строку для изменения
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
-- Обновляем баланс
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;
```

---

### **3. Использование атомарных операций**
Некоторые СУБД поддерживают атомарные операции, которые гарантируют, что обновление будет выполнено без конфликтов.

**Пример в PostgreSQL:**
```sql
UPDATE accounts SET balance = balance - 100 WHERE id = 1 RETURNING balance;
```

---

### **4. Применение паттерна "Optimistic Concurrency Control" (OCC)**
Добавляется столбец `version` в таблицу. При обновлении проверяется, что версия не изменилась.

**Пример на C# с Entity Framework:**
```csharp
var account = dbContext.Accounts.First(a => a.Id == 1);
account.Balance -= 100;
dbContext.SaveChanges(); // Если версия изменилась, будет выброшено исключение
```

---

### **5. Использование хранимых процедур**
Хранимые процедуры позволяют выполнять несколько операций как одну атомарную единицу, что снижает вероятность Race Condition.

---

## **Вывод**
Race Condition в базе данных — это серьёзная проблема, которая может привести к потере или искажению данных. Чтобы избежать её, используйте:
- правильные **уровни изоляции транзакций**,
- **блокировки** (оптимистичные или пессимистичные),
- **атомарные операции**,
- **паттерны управления конкурентностью** (например, OCC).

Вот аналогичные примеры блокировки строк для **Microsoft SQL Server (MSSQL)** и **Oracle** с использованием пессимистичных блокировок в транзакциях.

---

### **1. Microsoft SQL Server (MSSQL)**

В MSSQL для блокировки строки на время транзакции используется подсказка `WITH (UPDLOCK, ROWLOCK)`.

```sql
BEGIN TRANSACTION;

-- Блокируем строку для изменения
SELECT * FROM accounts WITH (UPDLOCK, ROWLOCK) WHERE id = 1;

-- Обновляем баланс
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

COMMIT TRANSACTION;
```

**Пояснения:**
- `UPDLOCK` — блокирует строку для обновления, чтобы другие транзакции не могли её изменить.
- `ROWLOCK` — указывает, что блокировка должна применяться на уровне строки, а не страницы или таблицы.

---

### **2. Oracle**

В Oracle для блокировки строки используется конструкция `SELECT ... FOR UPDATE`.

```sql
-- Начало транзакции (в Oracle транзакция начинается автоматически при первом операторе DML)
-- Блокируем строку для изменения
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;

-- Обновляем баланс
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- Фиксируем транзакцию
COMMIT;
```

**Пояснения:**
- `FOR UPDATE` — блокирует выбранные строки, чтобы другие транзакции не могли их изменить до завершения текущей транзакции.
- В Oracle транзакция начинается автоматически при первом операторе `INSERT`, `UPDATE`, `DELETE` или `SELECT ... FOR UPDATE`.

---

### **Дополнительные замечания**
- В **MSSQL** можно также использовать `WITH (XLOCK, ROWLOCK)` для эксклюзивной блокировки строки.
- В **Oracle** можно использовать `FOR UPDATE NOWAIT`, чтобы не ждать освобождения блокировки, или `FOR UPDATE WAIT n`, чтобы указать время ожидания.