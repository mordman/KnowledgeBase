## **1. Кластеризованный индекс (Clustered Index)**
### **Что это?**
Кластеризованный индекс **определяет физический порядок хранения данных** в таблице. Строки таблицы сортируются на диске в соответствии с ключом кластеризованного индекса.

### **Особенности:**
- **Только один** на таблицу (так как данные могут быть отсортированы только одним способом).
- **Ускоряет** операции чтения диапазонов данных (например, `WHERE id BETWEEN 10 AND 20`).
- **Замедляет** операции вставки/обновления, если они нарушают порядок (требуется пересортировка).

### **Пример:**
```sql
-- Создание таблицы с кластеризованным индексом по полю `id`
CREATE TABLE Users (
    id INT PRIMARY KEY CLUSTERED, -- Кластеризованный индекс
    name NVARCHAR(50),
    age INT
);
```
- Данные на диске будут отсортированы по `id`.
- Запрос `SELECT * FROM Users WHERE id = 5` будет очень быстрым, так как СУБД может сразу перейти к нужной строке.

---

## **2. Некластеризованный индекс (Nonclustered Index)**
### **Что это?**
Некластеризованный индекс — это **отдельная структура**, которая содержит копии ключей и указатели на строки данных. Он не изменяет физический порядок хранения данных.

### **Особенности:**
- Можно создать **несколько** на таблицу.
- **Ускоряет** поиск по конкретным столбцам, но не по диапазонам.
- **Требует дополнительное место** на диске (так как хранит копии ключей).
- **Может ссылаться** на кластеризованный индекс (если он есть) или на кучу (heap).

### **Пример:**
```sql
-- Создание некластеризованного индекса по полю `name`
CREATE INDEX IX_Users_Name ON Users(name);
```
- Запрос `SELECT * FROM Users WHERE name = 'Alice'` будет быстрее, так как СУБД использует индекс `IX_Users_Name`.
- Если кластеризованный индекс отсутствует, некластеризованный индекс будет ссылаться на **физический адрес строки** (RID).

---

## **3. Как работают вместе?**
- Если есть **кластеризованный индекс**, некластеризованные индексы хранят **указатели на ключи кластеризованного индекса** (а не на физические адреса).
- Если кластеризованного индекса нет, некластеризованные индексы ссылаются на **RID** (Row ID — физический адрес строки в куче).

### **Пример работы:**
```sql
-- Таблица без кластеризованного индекса
CREATE TABLE Products (
    id INT,
    name NVARCHAR(50),
    price DECIMAL(10, 2)
);

-- Некластеризованный индекс по `name`
CREATE INDEX IX_Products_Name ON Products(name);
```
- Индекс `IX_Products_Name` будет хранить пары `(name, RID)`.
- При запросе `SELECT * FROM Products WHERE name = 'Laptop'` СУБД найдёт `RID` в индексе и перейдёт к строке по физическому адресу.

---

## **4. Когда что использовать?**
| **Кластеризованный индекс** | **Некластеризованный индекс** |
|-----------------------------|--------------------------------|
| На первичном ключе (`PRIMARY KEY`). | На часто используемых столбцах для фильтрации (`WHERE`). |
| На столбцах с диапазонными запросами (`BETWEEN`, `>`, `<`). | На столбцах с точными запросами (`=`, `IN`). |
| На столбцах с высокой селективностью (уникальные значения). | На столбцах с низкой селективностью (много повторов). |

---

## **5. Пример с реальными данными**
### **Таблица:**
```sql
CREATE TABLE Orders (
    order_id INT PRIMARY KEY CLUSTERED,
    customer_id INT,
    order_date DATETIME,
    amount DECIMAL(10, 2)
);

-- Некластеризованный индекс по `customer_id`
CREATE INDEX IX_Orders_CustomerId ON Orders(customer_id);
```

### **Запросы:**
1. **Быстрый запрос по кластеризованному индексу:**
   ```sql
   SELECT * FROM Orders WHERE order_id = 100; -- O(1)
   ```
2. **Быстрый запрос по некластеризованному индексу:**
   ```sql
   SELECT * FROM Orders WHERE customer_id = 5; -- Использует IX_Orders_CustomerId
   ```
3. **Диапазонный запрос (эффективен с кластеризованным индексом):**
   ```sql
   SELECT * FROM Orders WHERE order_id BETWEEN 100 AND 200; -- Быстро, так как данные отсортированы
   ```

---

## **6. Под капотом: как хранятся данные**
### **Кластеризованный индекс:**
- Данные хранятся в **B-дереве** (сбалансированное дерево), где листья — это сами строки таблицы.
- Пример структуры:
  ```
  [Root] → [Уровень 1] → [Листья (строки таблицы)]
  ```

### **Некластеризованный индекс:**
- Хранит **B-дерево**, где листья содержат **ключ индекса + указатель** (на кластеризованный ключ или RID).
- Пример структуры:
  ```
  [Root] → [Уровень 1] → [Листья (ключ, указатель)]
  ```

---

## **7. Плюсы и минусы**
| **Тип индекса**       | **Плюсы**                                  | **Минусы**                                  |
|-----------------------|--------------------------------------------|---------------------------------------------|
| **Кластеризованный**  | Быстрый доступ к диапазонам данных.       | Только один на таблицу. Медленные вставки/обновления. |
| **Некластеризованный**| Можно создать несколько. Быстрый точечный поиск. | Занимает дополнительное место. Медленнее для диапазонов. |

---

## **8. Практические рекомендации**
- **Всегда создавайте кластеризованный индекс** на первичном ключе (если он есть).
- **Некластеризованные индексы** добавляйте для столбцов, по которым часто идут запросы.
- **Избегайте избыточных индексов** — они замедляют вставку/обновление.
- **Мониторьте производительность** с помощью инструментов (например, SQL Server Execution Plan).

---