## **1. Кластеризованный индекс (Clustered Index)**
### **Что это?**
Кластеризованный индекс **определяет физический порядок хранения данных** в таблице. Строки таблицы сортируются на диске в соответствии с ключом кластеризованного индекса.

### **Особенности:**
- **Только один** на таблицу (так как данные могут быть отсортированы только одним способом).
- **Ускоряет** операции чтения диапазонов данных (например, `WHERE id BETWEEN 10 AND 20`).
- **Замедляет** операции вставки/обновления, если они нарушают порядок (требуется пересортировка).

### **Пример:**
```sql
-- Создание таблицы с кластеризованным индексом по полю `id`
CREATE TABLE Users (
    id INT PRIMARY KEY CLUSTERED, -- Кластеризованный индекс
    name NVARCHAR(50),
    age INT
);
```
- Данные на диске будут отсортированы по `id`.
- Запрос `SELECT * FROM Users WHERE id = 5` будет очень быстрым, так как СУБД может сразу перейти к нужной строке.

---

## **2. Некластеризованный индекс (Nonclustered Index)**
### **Что это?**
Некластеризованный индекс — это **отдельная структура**, которая содержит копии ключей и указатели на строки данных. Он не изменяет физический порядок хранения данных.

### **Особенности:**
- Можно создать **несколько** на таблицу.
- **Ускоряет** поиск по конкретным столбцам, но не по диапазонам.
- **Требует дополнительное место** на диске (так как хранит копии ключей).
- **Может ссылаться** на кластеризованный индекс (если он есть) или на кучу (heap).

### **Пример:**
```sql
-- Создание некластеризованного индекса по полю `name`
CREATE INDEX IX_Users_Name ON Users(name);
```
- Запрос `SELECT * FROM Users WHERE name = 'Alice'` будет быстрее, так как СУБД использует индекс `IX_Users_Name`.
- Если кластеризованный индекс отсутствует, некластеризованный индекс будет ссылаться на **физический адрес строки** (RID).

---

## **3. Как работают вместе?**
- Если есть **кластеризованный индекс**, некластеризованные индексы хранят **указатели на ключи кластеризованного индекса** (а не на физические адреса).
- Если кластеризованного индекса нет, некластеризованные индексы ссылаются на **RID** (Row ID — физический адрес строки в куче).

### **Пример работы:**
```sql
-- Таблица без кластеризованного индекса
CREATE TABLE Products (
    id INT,
    name NVARCHAR(50),
    price DECIMAL(10, 2)
);

-- Некластеризованный индекс по `name`
CREATE INDEX IX_Products_Name ON Products(name);
```
- Индекс `IX_Products_Name` будет хранить пары `(name, RID)`.
- При запросе `SELECT * FROM Products WHERE name = 'Laptop'` СУБД найдёт `RID` в индексе и перейдёт к строке по физическому адресу.

---

## **4. Когда что использовать?**
| **Кластеризованный индекс** | **Некластеризованный индекс** |
|-----------------------------|--------------------------------|
| На первичном ключе (`PRIMARY KEY`). | На часто используемых столбцах для фильтрации (`WHERE`). |
| На столбцах с диапазонными запросами (`BETWEEN`, `>`, `<`). | На столбцах с точными запросами (`=`, `IN`). |
| На столбцах с высокой селективностью (уникальные значения). | На столбцах с низкой селективностью (много повторов). |

---

## **5. Пример с реальными данными**
### **Таблица:**
```sql
CREATE TABLE Orders (
    order_id INT PRIMARY KEY CLUSTERED,
    customer_id INT,
    order_date DATETIME,
    amount DECIMAL(10, 2)
);

-- Некластеризованный индекс по `customer_id`
CREATE INDEX IX_Orders_CustomerId ON Orders(customer_id);
```

### **Запросы:**
1. **Быстрый запрос по кластеризованному индексу:**
   ```sql
   SELECT * FROM Orders WHERE order_id = 100; -- O(1)
   ```
2. **Быстрый запрос по некластеризованному индексу:**
   ```sql
   SELECT * FROM Orders WHERE customer_id = 5; -- Использует IX_Orders_CustomerId
   ```
3. **Диапазонный запрос (эффективен с кластеризованным индексом):**
   ```sql
   SELECT * FROM Orders WHERE order_id BETWEEN 100 AND 200; -- Быстро, так как данные отсортированы
   ```

---

## **6. Под капотом: как хранятся данные**
### **Кластеризованный индекс:**
- Данные хранятся в **B-дереве** (сбалансированное дерево), где листья — это сами строки таблицы.
- Пример структуры:
  ```
  [Root] → [Уровень 1] → [Листья (строки таблицы)]
  ```

### **Некластеризованный индекс:**
- Хранит **B-дерево**, где листья содержат **ключ индекса + указатель** (на кластеризованный ключ или RID).
- Пример структуры:
  ```
  [Root] → [Уровень 1] → [Листья (ключ, указатель)]
  ```

---

## **7. Плюсы и минусы**
| **Тип индекса**       | **Плюсы**                                  | **Минусы**                                  |
|-----------------------|--------------------------------------------|---------------------------------------------|
| **Кластеризованный**  | Быстрый доступ к диапазонам данных.       | Только один на таблицу. Медленные вставки/обновления. |
| **Некластеризованный**| Можно создать несколько. Быстрый точечный поиск. | Занимает дополнительное место. Медленнее для диапазонов. |

---

## **8. Практические рекомендации**
- **Всегда создавайте кластеризованный индекс** на первичном ключе (если он есть).
- **Некластеризованные индексы** добавляйте для столбцов, по которым часто идут запросы.
- **Избегайте избыточных индексов** — они замедляют вставку/обновление.
- **Мониторьте производительность** с помощью инструментов (например, SQL Server Execution Plan).

---
В статье подробно рассматриваются основы индексов в **SQL Server**, их типы, структура, и ответы на распространённые вопросы. Ниже — краткая выкладка и аналоги для **Oracle** и **PostgreSQL** в виде сводной таблицы.

---

### **Краткая выкладка по статье**
1. **Типы индексов**:
   - **Кластеризованный индекс**: хранит данные в листьях, определяет физический порядок строк. Таблица может иметь только один.
   - **Некластеризованный индекс**: хранит указатели на данные, может быть несколько на таблицу.

2. **Структура индекса**:
   - Индексы организованы как **сбалансированное дерево (B-tree)**.
   - Листья кластеризованного индекса содержат данные, некластеризованного — указатели на данные.

3. **Особенности**:
   - **Кластеризованный индекс** ускоряет доступ к данным, но только один на таблицу.
   - **Некластеризованный индекс** позволяет ускорить запросы по нескольким столбцам, но требует дополнительного доступа к данным.
   - **Составной индекс** — индекс по нескольким столбцам.
   - **Покрывающий индекс** — включает все столбцы, необходимые для запроса, чтобы избежать доступа к таблице.

4. **Когда использовать**:
   - Кластеризованный индекс — для часто используемых столбцов (например, первичный ключ).
   - Некластеризованный индекс — для ускорения запросов по другим столбцам.

---

### **Сводная таблица для SQL Server, Oracle и PostgreSQL**



| **Параметр**               | **SQL Server**                                                                 | **Oracle**                                                                                     | **PostgreSQL**                                                                                 |
|----------------------------|--------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|
| **Кластеризованный индекс** | Есть, определяет физический порядок строк. Таблица может иметь только один.              | Нет прямого аналога. Используется **Index-Organized Table (IOT)** — таблица хранится как индекс. | Нет прямого аналога. Используются **B-tree индексы** с указанием `CLUSTER` для физической пересортировки таблицы. |
| **Некластеризованный индекс** | Есть, хранит указатели на данные. Можно создать несколько на таблицу.                     | Есть, стандартный индекс (`CREATE INDEX`). Хранит указатели (`ROWID`).                          | Есть, стандартный индекс (`CREATE INDEX`). Хранит указатели (`TID`).                             |
| **Структура индекса**       | B-tree.                                                                       | B-tree (по умолчанию).                                                                         | B-tree (по умолчанию).                                                                        |
| **Составной индекс**        | Да, до 16 столбцов.                                                           | Да, до 32 столбцов.                                                                            | Да, без строгих ограничений на количество столбцов.                                            |
| **Покрывающий индекс**      | Да, включает дополнительные столбцы (`INCLUDE`).                                            | Да, можно добавить столбцы в индекс (`CREATE INDEX ... ON table(column1, column2) INCLUDE(column3)`). | Да, можно добавить столбцы в индекс (`CREATE INDEX ... ON table(column1) INCLUDE(column2)`).     |
| **Уникальный индекс**       | Да, для уникальных значений.                                                                 | Да, для уникальных значений.                                                                   | Да, для уникальных значений.                                                                   |
| **Index-Organized Table**   | Нет.                                                                           | Да, таблица хранится как индекс (`CREATE TABLE ... ORGANIZATION INDEX`).                       | Нет.                                                                                           |
| **Кластеры**                | Нет.                                                                           | Да, физически группируют данные из нескольких таблиц (`CREATE CLUSTER`).                      | Да, физически пересортировывает таблицу (`CLUSTER table_name USING index_name`).                |
| **Пример создания индекса** | `CREATE CLUSTERED INDEX idx_name ON table(column);`                          | `CREATE INDEX idx_name ON table(column);`                                                     | `CREATE INDEX idx_name ON table(column);`                                                     |
| **Пример IOT**               | —                                                                              | `CREATE TABLE table_name (column1 NUMBER, PRIMARY KEY) ORGANIZATION INDEX;`                    | —                                                                                              |
| **Пример кластера**          | —                                                                              | `CREATE CLUSTER cluster_name (column NUMBER);`                                                 | `CLUSTER table_name USING index_name;`                                                         |

---

### **Примеры для Oracle и PostgreSQL**

#### **Oracle**
1. **Создание Index-Organized Table (IOT):**
   ```sql
   CREATE TABLE employees_iot (
     employee_id NUMBER PRIMARY KEY,
     last_name VARCHAR2(50),
     first_name VARCHAR2(50)
   ) ORGANIZATION INDEX;
   ```

2. **Создание кластера:**
   ```sql
   CREATE CLUSTER emp_dept_cluster (
     department_id NUMBER(4)
   );
   CREATE TABLE departments (
     department_id NUMBER(4),
     department_name VARCHAR2(30)
   ) CLUSTER emp_dept_cluster(department_id);
   ```

#### **PostgreSQL**
1. **Создание B-tree индекса:**
   ```sql
   CREATE INDEX idx_employees_lastname ON employees(last_name);
   ```

2. **Физическая пересортировка таблицы (кластеризация):**
   ```sql
   CLUSTER employees USING idx_employees_lastname;
   ```

---

### **Выводы**
- **SQL Server**: Использует кластеризованные и некластеризованные индексы для оптимизации доступа к данным.
- **Oracle**: Использует **Index-Organized Tables** и **кластеры** для физической группировки данных.
- **PostgreSQL**: Использует **B-tree индексы** и команду `CLUSTER` для физической пересортировки таблицы.