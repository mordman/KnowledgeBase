## **Типы транзакций в PostgreSQL**

### **1. Простые транзакции**
- **Определение**: Последовательность SQL-запросов, объединённых в один блок.
- **Особенности**:
  - Начинаются с `BEGIN` или `START TRANSACTION`.
  - Завершаются `COMMIT` (сохранение изменений) или `ROLLBACK` (откат изменений).
  - Изолированы от других транзакций (уровень изоляции зависит от настроек).

**Пример:**
```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE user_id = 2;
COMMIT;
```
Если на втором шаге произойдёт ошибка, изменения не будут применены.

---

### **2. Вложенные транзакции (Savepoints)**
- **Определение**: Транзакции внутри транзакций, позволяющие откатывать только часть изменений.
- **Особенности**:
  - PostgreSQL не поддерживает полноценные вложенные транзакции, но есть **точки сохранения (savepoints)**.
  - Создаются с `SAVEPOINT <имя>`.
  - Откат к точке: `ROLLBACK TO SAVEPOINT <имя>`.
  - Удаление точки: `RELEASE SAVEPOINT <имя>`.

**Пример:**
```sql
BEGIN;
    UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;
    SAVEPOINT before_transfer;
    UPDATE accounts SET balance = balance + 100 WHERE user_id = 2;
    -- Ошибка! Откатываем только часть:
    ROLLBACK TO SAVEPOINT before_transfer;
    -- Альтернативные действия...
COMMIT;
```

---

### **3. Распределённые транзакции (2PC)**
- **Определение**: Транзакции, затрагивающие несколько баз данных или серверов.
- **Особенности**:
  - В PostgreSQL реализованы через **двухфазный коммит (2PC)**.
  - Используются команды `PREPARE TRANSACTION` и `COMMIT PREPARED`.
  - Позволяют синхронизировать изменения в разных БД.

**Пример:**
```sql
BEGIN;
    UPDATE db1.accounts SET balance = balance - 100 WHERE user_id = 1;
    UPDATE db2.accounts SET balance = balance + 100 WHERE user_id = 2;
PREPARE TRANSACTION 'transfer_123';
-- На другом сервере:
COMMIT PREPARED 'transfer_123';
```

---

## **Уровни изоляции транзакций**
PostgreSQL поддерживает 4 уровня изоляции (по стандарту SQL):

| Уровень               | Описание                                                                 |
|-----------------------|--------------------------------------------------------------------------|
| **Read Uncommitted**  | Видны незафиксированные изменения других транзакций (не используется в PG). |
| **Read Committed**    | Видны только зафиксированные изменения (по умолчанию в PG).              |
| **Repeatable Read**   | Гарантирует, что данные не изменятся в течение транзакции.               |
| **Serializable**      | Самый строгий уровень, предотвращает фантомные чтения.                   |

**Пример установки уровня:**
```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN;
    -- Запросы...
COMMIT;
```

---

## **Особенности транзакций в PostgreSQL**
1. **MVCC (Multi-Version Concurrency Control)**:
   - PostgreSQL использует механизм версий строк, что позволяет избегать блокировок при чтении.
   - Каждая транзакция видит "снимок" данных на момент её начала.

2. **Блокировки**:
   - Транзакции могут блокировать строки или таблицы (`SELECT ... FOR UPDATE`).
   - Длительные блокировки могут приводить к взаимоблокировкам (deadlocks).

3. **Автофиксация**:
   - Если транзакция не завершена явно, PostgreSQL автоматически выполнит `ROLLBACK` при разрыве соединения.

---

## **Примеры использования**
### **1. Перевод средств между счётами**
```sql
BEGIN;
    UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;
    UPDATE accounts SET balance = balance + 100 WHERE user_id = 2;
COMMIT;
```

### **2. Откат при ошибке**
```sql
BEGIN;
    INSERT INTO orders (user_id, amount) VALUES (1, 100);
    -- Ошибка: недостаточно средств
    ROLLBACK;
```

### **3. Использование точек сохранения**
```sql
BEGIN;
    INSERT INTO logs (message) VALUES ('Start');
    SAVEPOINT before_update;
    UPDATE users SET status = 'active' WHERE id = 1;
    -- Ошибка! Откатываем только UPDATE:
    ROLLBACK TO SAVEPOINT before_update;
    INSERT INTO logs (message) VALUES('Rollback update');
COMMIT;
```

---

## **Выводы**
- Транзакции в PostgreSQL обеспечивают **атомарность, согласованность, изолированность и долговечность (ACID)**.
- **Вложенные транзакции** реализуются через `SAVEPOINT`.
- **Распределённые транзакции** требуют использования `PREPARE TRANSACTION`.
- Уровни изоляции позволяют контролировать видимость изменений.

## **Уровни изоляции транзакций**

Уровни изоляции транзакций определяют, **как транзакции взаимодействуют друг с другом** и **какие данные видны** в процессе выполнения. PostgreSQL поддерживает **4 уровня изоляции**, каждый из которых подходит для разных сценариев.

---

## **1. Уровни изоляции в PostgreSQL**



| Уровень изоляции       | Описание                                                                                     | Проблемы, которые могут возникнуть                     |
|------------------------|----------------------------------------------------------------------------------------------|---------------------------------------------------------|
| **Read Uncommitted**   | Транзакция видит **незафиксированные изменения** других транзакций.                          | Грязное чтение, неповторяющееся чтение, фантомы.        |
| **Read Committed**      | Транзакция видит **только зафиксированные изменения** (по умолчанию в PostgreSQL).           | Неповторяющееся чтение, фантомы.                        |
| **Repeatable Read**     | Транзакция видит **снимок данных на момент начала транзакции**. Изменения других транзакций не видны. | Фантомы.                                                |
| **Serializable**        | Самый строгий уровень. Транзакции выполняются так, как будто они **идут последовательно**. | Нет проблем, но возможны взаимоблокировки.             |

---

## **2. Проблемы, связанные с уровнями изоляции**

### **2.1. Грязное чтение (Dirty Read)**
- **Что это?** Транзакция читает **незафиксированные изменения** другой транзакции, которые могут быть отменены.
- **Когда возникает?** Только на уровне **Read Uncommitted** (в PostgreSQL этот уровень **не поддерживается** полностью, но можно эмулировать с помощью `SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED`).

---

### **2.2. Неповторяющееся чтение (Non-Repeatable Read)**
- **Что это?** Транзакция читает одну и ту же строку **дважды**, но между чтениями другая транзакция **обновила и зафиксировала** эту строку.
- **Когда возникает?** На уровнях **Read Committed** и ниже.

**Пример:**
```sql
-- Транзакция 1 (Read Committed)
BEGIN;
SELECT balance FROM accounts WHERE id = 1;  -- Видит balance = 100

-- Транзакция 2 обновляет и фиксирует balance
BEGIN;
UPDATE accounts SET balance = 200 WHERE id = 1;
COMMIT;

-- Транзакция 1 снова читает balance
SELECT balance FROM accounts WHERE id = 1;  -- Теперь видит balance = 200 (изменилось!)
COMMIT;
```

---

### **2.3. Фантомное чтение (Phantom Read)**
- **Что это?** Транзакция выполняет **один и тот же запрос дважды**, но между выполнениями другая транзакция **добавила или удалила строки**, соответствующие условию.
- **Когда возникает?** На уровнях **Read Committed** и **Repeatable Read**.

**Пример:**
```sql
-- Транзакция 1 (Repeatable Read)
BEGIN;
SELECT COUNT(*) FROM accounts WHERE balance > 100;  -- Видит 5 строк

-- Транзакция 2 добавляет новую строку
BEGIN;
INSERT INTO accounts (id, balance) VALUES (6, 150);
COMMIT;

-- Транзакция 1 снова выполняет тот же запрос
SELECT COUNT(*) FROM accounts WHERE balance > 100;  -- Теперь видит 6 строк (фантом!)
COMMIT;
```

---

## **3. Когда использовать каждый уровень изоляции?**

### **3.1. Read Committed (по умолчанию)**
- **Когда использовать?**
  - Для **большинства OLTP-приложений** (веб-приложения, CRM, ERP).
  - Когда нужна **балансировка между производительностью и согласованностью**.
- **Проблемы:** Неповторяющееся чтение, фантомы.
- **Пример:**
  ```sql
  SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
  BEGIN;
  -- Ваши запросы
  COMMIT;
  ```

---

### **3.2. Repeatable Read**
- **Когда использовать?**
  - Когда нужно **гарантировать, что данные не изменятся** в процессе транзакции.
  - Например, для **финансовых операций**, где важно избежать неповторяющегося чтения.
- **Проблемы:** Фантомы (но в PostgreSQL их можно избежать с помощью `SELECT ... FOR SHARE`).
- **Пример:**
  ```sql
  SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
  BEGIN;
  -- Ваши запросы
  COMMIT;
  ```

---

### **3.3. Serializable**
- **Когда использовать?**
  - Когда нужна **максимальная согласованность** (например, в **банковских системах**).
  - Для **сложных транзакций**, где важно избежать всех аномалий.
- **Проблемы:** Возможны **взаимоблокировки** и **низкая производительность**.
- **Пример:**
  ```sql
  SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
  BEGIN;
  -- Ваши запросы
  COMMIT;
  ```

---

## **4. Примеры использования уровней изоляции**

### **4.1. Read Committed (по умолчанию)**
**Сценарий:** Обычное веб-приложение, где пользователи редактируют профили.
```sql
-- Уровень изоляции по умолчанию (Read Committed)
BEGIN;
-- Пользователь обновляет свой профиль
UPDATE users SET name = 'Новое имя' WHERE id = 1;
-- Пользователь читает данные другого пользователя
SELECT * FROM users WHERE id = 2;
COMMIT;
```

---

### **4.2. Repeatable Read**
**Сценарий:** Финансовая операция, где важно избежать изменений данных в процессе транзакции.
```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
-- Чтение баланса
SELECT balance FROM accounts WHERE id = 1;
-- Обновление баланса
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- Повторное чтение баланса (гарантированно то же значение)
SELECT balance FROM accounts WHERE id = 1;
COMMIT;
```

---

### **4.3. Serializable**
**Сценарий:** Банковский перевод, где важно избежать всех аномалий.
```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN;
-- Проверка баланса
SELECT balance FROM accounts WHERE id = 1;
-- Если баланс достаточен, выполняем перевод
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

---

## **5. Как избежать проблем на разных уровнях изоляции?**

### **5.1. Избегание неповторяющегося чтения**
- Используйте **`Repeatable Read`** или **`Serializable`**.
- Используйте **блокировки** (`SELECT ... FOR UPDATE` или `SELECT ... FOR SHARE`).

**Пример:**
```sql
BEGIN;
-- Блокируем строку для обновления
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
-- Обновляем баланс
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;
```

---

### **5.2. Избегание фантомов**
- Используйте **`Serializable`**.
- Используйте **`SELECT ... FOR SHARE`** для блокировки строк.

**Пример:**
```sql
BEGIN;
-- Блокируем строки, соответствующие условию
SELECT * FROM accounts WHERE balance > 100 FOR SHARE;
-- Вставляем или обновляем данные
INSERT INTO accounts (id, balance) VALUES (6, 150);
COMMIT;
```

---

### **5.3. Оптимизация производительности**
- **Read Committed** — самый быстрый уровень, подходит для большинства задач.
- **Repeatable Read** — медленнее, но избегает неповторяющегося чтения.
- **Serializable** — самый медленный, но самый надёжный.

---

## **6. Как проверить текущий уровень изоляции?**
```sql
-- Посмотреть текущий уровень изоляции
SHOW transaction_isolation;

-- Установить уровень изоляции для текущей транзакции
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- Установить уровень изоляции для всей сессии
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

---

## **7. Итоговые рекомендации**
| Уровень изоляции       | Когда использовать                                                                           | Проблемы                                  |
|------------------------|---------------------------------------------------------------------------------------------|-------------------------------------------|
| **Read Committed**     | Большинство OLTP-приложений (веб, CRM, ERP).                                                 | Неповторяющееся чтение, фантомы.          |
| **Repeatable Read**    | Финансовые операции, где важна согласованность чтения.                                      | Фантомы.                                  |
| **Serializable**       | Банковские системы, сложные транзакции, где важна максимальная согласованность.              | Взаимоблокировки, низкая производительность. |

---

## **8. Пример: Оптимизация уровня изоляции**
**Задача:** Реализовать перевод денег между счетами.

**Решение с Repeatable Read:**
```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
-- Блокируем строки для обновления
SELECT * FROM accounts WHERE id IN (1, 2) FOR UPDATE;
-- Проверяем баланс
SELECT balance FROM accounts WHERE id = 1;
-- Если баланс достаточен, выполняем перевод
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

---