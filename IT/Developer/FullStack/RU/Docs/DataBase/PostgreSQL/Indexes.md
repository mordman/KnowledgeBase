## **1. Общий обзор индексов в Oracle**

### **1.1. Основные типы индексов**
Oracle поддерживает множество типов индексов, каждый из которых оптимизирован для определённых задач.



| Тип индекса               | Описание                                                                                     | Пример использования                          |
|---------------------------|----------------------------------------------------------------------------------------------|-----------------------------------------------|
| **B-Tree Index**          | Стандартный тип индекса для большинства задач. Поддерживает поиск по диапазону, точному совпадению, сортировку. | `CREATE INDEX idx_name ON table(column);` |
| **Bitmap Index**          | Индекс для столбцов с низкой кардинальностью (мало уникальных значений). Эффективен для аналитических запросов. | Индекс на столбце "Пол" или "Статус". |
| **Function-Based Index**  | Индекс на основе функции или выражения. Позволяет ускорить запросы с функциями в `WHERE`. | Индекс на `LOWER(name)`. |
| **Composite Index**       | Индекс на нескольких столбцах. Эффективен для запросов с фильтрацией по нескольким столбцам. | Индекс на `(last_name, first_name)`. |
| **Unique Index**          | Гарантирует уникальность значений в столбце или группе столбцов. | `UNIQUE CONSTRAINT`. |
| **Text Index**            | Индекс для полнотекстового поиска (Oracle Text). | Поиск по тексту в документах или статьях. |
| **Spatial Index**         | Индекс для геопространственных данных. | Поиск объектов на карте. |
| **Domain Index**          | Индекс для пользовательских типов данных. | Индекс для специфичных типов (например, мультимедиа). |

---

### **1.2. B-Tree vs Bitmap индексы**
- **B-Tree Index**:
  - Подходит для **OLTP-систем** (много операций вставки/обновления/удаления).
  - Эффективен для столбцов с **высокой кардинальностью** (много уникальных значений).
  - Пример:
    ```sql
    CREATE INDEX idx_customer_name ON Customers(LastName);
    ```

- **Bitmap Index**:
  - Подходит для **OLAP-систем** (аналитические запросы, мало изменений данных).
  - Эффективен для столбцов с **низкой кардинальностью** (мало уникальных значений, например, "Пол" или "Регион").
  - Пример:
    ```sql
    CREATE BITMAP INDEX idx_customer_gender ON Customers(Gender);
    ```

---

## **2. Составные индексы (Composite Indexes)**
### **2.1. Описание**
Составные индексы создаются на **нескольких столбцах** и эффективны для запросов, которые фильтруют или сортируют данные по нескольким столбцам.

### **2.2. Правило префикса (Leftmost Prefix Rule)**
Oracle, как и другие СУБД, использует **префиксное правило**:
- Индекс на `(A, B)` ускорит запросы по `A` и `(A, B)`, но **не ускорит** запрос только по `B`.

#### **Пример**
```sql
-- Создание составного индекса
CREATE INDEX idx_customer_name_email ON Customers(LastName, Email);

-- Запросы, которые будут использовать индекс:
SELECT * FROM Customers WHERE LastName = 'Иванов';
SELECT * FROM Customers WHERE LastName = 'Иванов' AND Email = 'ivanov@example.com';

-- Запрос, который НЕ будет использовать индекс:
SELECT * FROM Customers WHERE Email = 'ivanov@example.com';
```

### **2.3. Как выбрать порядок столбцов?**
1. **Столбцы с высокой селективностью** (много уникальных значений) ставьте первыми.
2. **Столбцы, которые чаще используются в `WHERE`**, ставьте первыми.
3. **Столбцы, используемые в `ORDER BY`**, ставьте первыми.

---

## **3. Полнотекстовый поиск (Oracle Text)**
### **3.1. Описание**
Oracle Text — это встроенное решение для **полнотекстового поиска**, которое поддерживает:
- Поиск по словам и фразам.
- Учёт морфологии (для многих языков).
- Игнорирование стоп-слов.
- Ранжирование результатов по релевантности.

### **3.2. Настройка Oracle Text**
#### **Шаг 1: Создание индекса Oracle Text**
```sql
-- Создание индекса Oracle Text
CREATE INDEX idx_articles_text ON Articles(Content)
INDEXTYPE IS CTXSYS.CONTEXT;
```

#### **Шаг 2: Использование полнотекстового поиска**
```sql
-- Поиск по слову "PostgreSQL"
SELECT * FROM Articles
WHERE CONTAINS(Content, 'PostgreSQL') > 0;

-- Поиск по фразе "PostgreSQL и индексы"
SELECT * FROM Articles
WHERE CONTAINS(Content, 'PostgreSQL AND индексы') > 0;

-- Поиск с учётом словоформ (для английского)
SELECT * FROM Articles
WHERE CONTAINS(Content, 'run', 1) > 0;
```

#### **Шаг 3: Поиск с ранжированием**
```sql
-- Поиск с ранжированием по релевантности
SELECT A.*, SCORE(1) AS Relevance
FROM Articles A
WHERE CONTAINS(Content, 'PostgreSQL AND индексы', 1) > 0
ORDER BY Relevance DESC;
```

### **3.3. Операторы Oracle Text**
| Оператор       | Описание                                                                 |
|----------------|--------------------------------------------------------------------------|
| `CONTAINS`     | Основной оператор для полнотекстового поиска.                          |
| `SCORE`        | Возвращает релевантность результата.                                    |
| `CATSEARCH`    | Поиск по категориям.                                                     |
| `MATCHES`      | Поиск с учётом шаблонов.                                                 |

### **3.4. Когда использовать Oracle Text?**
- Для поиска по **большим текстовым полям** (статьи, документы, комментарии).
- Если нужен **поиск по словам, фразам или формам слов**.
- Если `LIKE '%text%'` работает слишком медленно.

---

## **4. Функциональные индексы (Function-Based Indexes)**
### **4.1. Описание**
Функциональные индексы позволяют создать индекс на основе **функции или выражения**. Это ускоряет запросы, которые используют функции в `WHERE`.

### **4.2. Пример**
```sql
-- Создание функционального индекса на LOWER(LastName)
CREATE INDEX idx_customer_name_lower ON Customers(LOWER(LastName));

-- Использование в запросе
SELECT * FROM Customers WHERE LOWER(LastName) = 'иванов';
```

### **4.3. Когда использовать?**
- Если часто используются **функции в запросах** (например, `LOWER`, `UPPER`, `TO_CHAR`).
- Если нужно ускорить запросы с **вычислениями**.

---

## **5. Bitmap индексы**
### **5.1. Описание**
Bitmap индексы эффективны для столбцов с **низкой кардинальностью** (мало уникальных значений), например, "Пол", "Статус", "Регион". Часто используются в **OLAP-системах**.

### **5.2. Пример**
```sql
-- Создание Bitmap индекса
CREATE BITMAP INDEX idx_customer_gender ON Customers(Gender);

-- Использование в запросе
SELECT * FROM Customers WHERE Gender = 'М';
```

### **5.3. Когда использовать?**
- Для **аналитических запросов** (OLAP).
- Для столбцов с **малым количеством уникальных значений**.

---

## **6. Примеры использования индексов**
### **6.1. Проверка использования индекса**
Чтобы узнать, использует ли Oracle ваш индекс, используйте **EXPLAIN PLAN**:
```sql
-- Включение отображения плана выполнения
EXPLAIN PLAN FOR
SELECT * FROM Customers WHERE LastName = 'Иванов';

-- Просмотр плана
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```
- Если в плане есть **`INDEX RANGE SCAN`**, значит индекс используется.
- Если **`FULL TABLE SCAN`**, индекс не используется.

---

### **6.2. Рекомендации по использованию индексов**
1. **Не создавайте индексы на все столбцы** — каждый индекс замедляет `INSERT`, `UPDATE`, `DELETE`.
2. **Используйте составные индексы** для часто используемых комбинаций столбцов.
3. **Следите за порядком столбцов** в составных индексах.
4. **Используйте функциональные индексы**, если часто используются функции в запросах.
5. **Используйте Bitmap индексы** для столбцов с низкой кардинальностью.
6. **Обновляйте статистику** (`ANALYZE TABLE` или `DBMS_STATS`), чтобы оптимизатор запросов работал корректно.
7. **Удаляйте неиспользуемые индексы** — они занимают место и замедляют запись.

---

## **7. Сводная таблица по индексам в Oracle**



| Тип индекса               | Описание                                                                                     | Пример использования                          | Примечания                                  |
|---------------------------|----------------------------------------------------------------------------------------------|-----------------------------------------------|--------------------------------------------|
| **B-Tree Index**          | Стандартный индекс для большинства задач.                                                   | `CREATE INDEX idx_name ON table(column);`    | Подходит для OLTP.                          |
| **Bitmap Index**          | Индекс для столбцов с низкой кардинальностью.                                               | Индекс на столбце "Пол" или "Статус".         | Подходит для OLAP.                          |
| **Function-Based Index**  | Индекс на основе функции или выражения.                                                     | Индекс на `LOWER(name)`.                      | Ускоряет запросы с функциями.               |
| **Composite Index**       | Индекс на нескольких столбцах.                                                              | Индекс на `(last_name, first_name)`.           | Порядок столбцов важен.                     |
| **Unique Index**          | Гарантирует уникальность значений.                                                          | `UNIQUE CONSTRAINT`.                          | Может быть B-Tree или Bitmap.               |
| **Text Index**            | Индекс для полнотекстового поиска (Oracle Text).                                             | Поиск по тексту в документах или статьях.     | Требует настройки Oracle Text.              |
| **Spatial Index**         | Индекс для геопространственных данных.                                                      | Поиск объектов на карте.                      | Требует типа данных `SDO_GEOMETRY`.         |
| **Domain Index**          | Индекс для пользовательских типов данных.                                                   | Индекс для специфичных типов (например, мультимедиа). | Требует настройки пользовательских типов. |

---