### **1. List<T>**
- **Структура**: Динамический массив (массив с автоматическим изменением размера).
- **Под капотом**:
  - Хранит элементы в непрерывном блоке памяти (как обычный массив).
  - При добавлении элемента, если места нет, создаётся новый массив (обычно в 2 раза больше) и элементы копируются туда.
  - Индексация работает через смещение от начала массива (O(1)).
  - Вставка/удаление в середину требует сдвига элементов (O(n)).

---

### **2. Dictionary<TKey, TValue>**
- **Структура**: Хеш-таблица (массив "корзин" + связанные списки для разрешения коллизий).
- **Под капотом**:
  - Использует хеш-функцию для преобразования ключа в индекс массива.
  - Каждая "корзина" содержит список пар ключ-значение (для разрешения коллизий).
  - При добавлении/поиске/удалении:
    1. Вычисляется хеш ключа.
    2. Определяется индекс корзины.
    3. Происходит поиск/добавление/удаление в связанном списке корзины.
  - В .NET используется открытая адресация (open addressing) для разрешения коллизий (начиная с .NET Core).

---

### **3. HashSet<T>**
- **Структура**: Хеш-таблица (аналогично Dictionary, но без значений).
- **Под капотом**:
  - Хранит только ключи (без значений).
  - Использует ту же логику хеширования и разрешения коллизий, что и Dictionary.
  - Операции добавления, удаления и поиска — O(1) в среднем случае.

---

### **4. Array (массив)**
- **Структура**: Фиксированный блок памяти для хранения элементов одного типа.
- **Под капотом**:
  - Элементы хранятся в непрерывной области памяти.
  - Размер фиксирован при создании.
  - Доступ по индексу — O(1) (вычисляется смещение от начала массива).
  - Добавление/удаление элементов невозможно без создания нового массива.

---

### **Ключевые моменты:**
- **List<T>** и **Array** используют непрерывную память, что даёт быстрый доступ по индексу.
- **Dictionary** и **HashSet** зависят от хеш-функции. Коллизии ухудшают производительность.
- **Dictionary** в .NET Core+ использует открытую адресацию, что уменьшает накладные расходы на хранение связанных списков.
---  

## Уникальность элементов в коллекциях C# обеспечивается разными механизмами в зависимости от типа коллекции. Вот как это работает под капотом:

### **1. HashSet<T>**
- **Механизм уникальности**:
  - **Хеш-таблица**: Каждый элемент хранится в "корзине", определяемой его хеш-кодом.
  - **Проверка на равенство**:
    1. Вычисляется хеш-код элемента (`GetHashCode()`).
    2. Если хеш-код уже существует, происходит проверка на равенство (`Equals()`) с элементами в той же корзине.
    3. Если элемент с таким же значением уже есть, добавление не происходит.
  - **Сложность**: O(1) в среднем случае (при хорошей хеш-функции).

- **Пример**:
  ```csharp
  var set = new HashSet<int> { 1, 2, 3 };
  set.Add(2); // Не добавится, так как 2 уже есть.
  ```

---

### **2. Dictionary<TKey, TValue>**
- **Механизм уникальности**:
  - Уникальность гарантируется **только для ключей** (не для значений!).
  - Использует ту же логику, что и `HashSet<T>`:
    1. Хеш-код ключа (`GetHashCode()`).
    2. Проверка на равенство (`Equals()`) при коллизиях.
  - Если ключ уже существует, значение перезаписывается (если разрешено).

- **Пример**:
  ```csharp
  var dict = new Dictionary<string, int> { { "a", 1 } };
  dict.Add("a", 2); // Выбросит исключение (ключ уже есть).
  dict["a"] = 2;    // Перезапишет значение для ключа "a".
  ```

---

### **3. List<T> и Array**
- **Уникальность не гарантируется** по умолчанию.
- Чтобы обеспечить уникальность, нужно вручную проверять наличие элемента (например, с помощью `Contains()`), что работает за O(n).

---

### **Ключевые моменты:**
- **Хеш-функция** (`GetHashCode()`) и **равенство** (`Equals()`) — основа уникальности в `HashSet<T>` и `Dictionary<TKey, TValue>`.
- Если переопределить `GetHashCode()` или `Equals()` некорректно, уникальность может нарушиться (например, два разных объекта с одинаковым хеш-кодом).
- **Коллизии** (одинаковые хеш-коды для разных объектов) разрешаются через проверку `Equals()`.

---

### **Пример с кастомным объектом**
```csharp
public class Person
{
    public string Name { get; set; }
    public override int GetHashCode() => Name.GetHashCode();
    public override bool Equals(object obj) => (obj as Person)?.Name == Name;
}

var set = new HashSet<Person> { new Person { Name = "Alice" } };
set.Add(new Person { Name = "Alice" }); // Не добавится (уже есть).
```