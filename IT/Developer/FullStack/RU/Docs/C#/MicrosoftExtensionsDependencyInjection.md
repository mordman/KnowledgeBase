**Microsoft.Extensions.DependencyInjection** — это официальный пакет от Microsoft для реализации **внедрения зависимостей (Dependency Injection, DI)** в .NET-приложениях. Он является частью **ASP.NET Core**, но может использоваться и в других типах приложений (консольных, десктопных, библиотеках).

---

## **Зачем нужен Microsoft.Extensions.DependencyInjection?**

### **1. Управление зависимостями**
Позволяет **централизованно управлять созданием и жизненным циклом объектов**, избегая жесткой привязки классов друг к другу. Это упрощает:
- Тестирование (можно подменять зависимости моками).
- Поддержку кода (изменения в одном месте не ломают остальные).
- Масштабируемость (легко добавлять новые зависимости).

### **2. Поддержка различных жизненных циклов объектов**
- **Transient**: Новый экземпляр создаётся при каждом запросе.
- **Scoped**: Один экземпляр на запрос (например, в веб-приложениях).
- **Singleton**: Один экземпляр на всё время работы приложения.

### **3. Интеграция с фреймворками**
- В **ASP.NET Core** встроен "из коробки".
- Можно использовать в **консольных приложениях**, **WinForms**, **WPF**, **Xamarin/MAUI**.

---

## **Примеры использования**

### **1. Базовый пример: регистрация и внедрение зависимости**

#### **Шаг 1: Установка пакета**
```bash
dotnet add package Microsoft.Extensions.DependencyInjection
```

#### **Шаг 2: Регистрация зависимостей**
```csharp
using Microsoft.Extensions.DependencyInjection;

// Создаём контейнер DI
var serviceProvider = new ServiceCollection()
    // Регистрируем зависимость как Transient (новый экземпляр каждый раз)
    .AddTransient<IMyService, MyService>()
    // Регистрируем как Singleton (один экземпляр на всё приложение)
    .AddSingleton<IMyRepository, MyRepository>()
    .BuildServiceProvider();
```

#### **Шаг 3: Использование зависимости**
```csharp
// Получаем экземпляр сервиса из контейнера
var myService = serviceProvider.GetRequiredService<IMyService>();
myService.DoWork();
```

---

### **2. Пример в ASP.NET Core**
В **ASP.NET Core** DI уже настроен по умолчанию. Достаточно зарегистрировать зависимости в `Program.cs`:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Регистрируем зависимости
builder.Services.AddTransient<IMyService, MyService>();
builder.Services.AddScoped<IMyRepository, MyRepository>();

var app = builder.Build();
```

#### **Использование в контроллере**
```csharp
public class MyController : Controller
{
    private readonly IMyService _myService;

    // Зависимость автоматически внедряется через конструктор
    public MyController(IMyService myService)
    {
        _myService = myService;
    }

    public IActionResult Index()
    {
        _myService.DoWork();
        return View();
    }
}
```

---

### **3. Пример с разными жизненными циклами**
```csharp
// Transient: новый экземпляр при каждом вызове
services.AddTransient<ITransientService, TransientService>();

// Scoped: один экземпляр на HTTP-запрос (в веб-приложениях)
services.AddScoped<IScopedService, ScopedService>();

// Singleton: один экземпляр на всё приложение
services.AddSingleton<ISingletonService, SingletonService>();
```

---

## **Сценарии использования**



| **Сценарий**                     | **Описание**                                                                                     | **Пример**                                                                                     |
|-----------------------------------|-------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| **Веб-приложения (ASP.NET Core)** | Управление зависимостями для контроллеров, сервисов, репозиториев.                           | Регистрация `DbContext`, сервисов авторизации, репозиториев.                                  |
| **Консольные утилиты**            | Централизованное управление зависимостями для скриптов или фоновых задач.                     | Логгеры, сервисы для работы с файлами, API-клиенты.                                            |
| **Тестирование**                  | Подмена реальных зависимостей на mock-объекты для модульного тестирования.                     | Использование `Moq` или `NSubstitute` для создания mock-репозиториев.                       |
| **Десктопные приложения**         | Управление зависимостями в WinForms, WPF, MAUI.                                                | Сервисы для работы с БД, настройками, API.                                                    |
| **Микросервисы**                  | Изоляция зависимостей между сервисами, упрощение интеграционного тестирования.                 | Регистрация клиентов для взаимодействия с другими микросервисами (например, через gRPC).      |
| **Библиотеки и SDK**              | Предоставление гибкости пользователям библиотеки для замены стандартных реализаций.             | Логгеры, кэш, HTTP-клиенты.                                                                    |

---

## **Плюсы и минусы**

### **Плюсы**
✅ **Упрощает тестирование** (можно легко подменять зависимости).
✅ **Снижает связанность кода** (классы не создают зависимости напрямую).
✅ **Централизованное управление** (все зависимости регистрируются в одном месте).
✅ **Гибкость** (можно легко менять реализации без изменения кода, который их использует).

### **Минусы**
❌ **Сложность настройки** для больших проектов.
❌ **Производительность** (незначительные накладные расходы на разрешение зависимостей).
❌ **Скрытые зависимости** (не всегда очевидно, какие зависимости использует класс).

---
В контексте **Microsoft.Extensions.DependencyInjection** (и вообще в .NET) **`Scoped`** — это один из трёх основных **жизненных циклов** (lifetimes) зависимостей, наряду с **`Transient`** и **`Singleton`**. Давай разберём, почему в примере с базой данных пациентов я использовал именно **`Scoped`** для регистрации `IPatientService` и почему это важно.

---

## **1. Что такое Scoped?**
**Scoped** означает, что **один экземпляр зависимости создаётся на один "scope"** (обычно — на один HTTP-запрос в веб-приложениях или на одну "операцию" в консольных/десктопных приложениях).
- В **ASP.NET Core** `Scoped` привязан к **HTTP-запросу**: все сервисы, зарегистрированные как `Scoped`, будут одинаковыми в рамках одного запроса, но разными для разных запросов.
- В **консольных приложениях** `Scoped` обычно привязан к **одному "блоку работы"** (например, к одному вызову `using var scope = serviceProvider.CreateScope()`).

---

## **2. Почему Scoped для `IPatientService`?**

### **А. Работа с Entity Framework Core**
- **`AppDbContext`** (контекст EF Core) **всегда регистрируется как `Scoped`** (или `Transient` в редких случаях).
  **Почему?**
  - Контекст EF Core **не потокобезопасен** (не поддерживает многопоточный доступ).
  - Контекст **отслеживает изменения** (change tracking) в рамках одной "операции" (например, одного HTTP-запроса или одной транзакции).
  - Если использовать `Singleton`, контекст будет **разделяться между разными запросами**, что приведёт к **конфликтам, утечкам памяти и ошибкам**.

- **`IPatientService` зависит от `AppDbContext`**, поэтому **должен иметь такой же или более короткий жизненный цикл**.
  - Если зарегистрировать `IPatientService` как `Singleton`, а `AppDbContext` как `Scoped`, то:
    - `IPatientService` (Singleton) **попытается использовать один и тот же `AppDbContext` для разных запросов** → **ошибки многопоточности**.
  - Если зарегистрировать оба как `Scoped`, то:
    - На каждый запрос (или операцию) будет создаваться **новый `AppDbContext` и новый `IPatientService`**, что **безопасно и корректно**.

---

### **Б. Пример проблемы с Singleton**
```csharp
// ❌ Некорректно: Singleton для сервиса, зависящего от Scoped-контекста
services.AddSingleton<IPatientService, PatientService>(); // Ошибка!
services.AddScoped<AppDbContext>();
```
**Что произойдёт?**
- `IPatientService` (Singleton) **создаётся один раз** и **хранит ссылку на `AppDbContext`**.
- При втором запросе `AppDbContext` **уже будет другим** (так как он `Scoped`), но `IPatientService` **попробует использовать старый контекст** → **исключения**.

---

### **В. Пример корректной регистрации**
```csharp
// ✅ Корректно: оба сервиса — Scoped
services.AddScoped<IPatientService, PatientService>();
services.AddScoped<AppDbContext>();
```
**Что происходит?**
- На каждый запрос (или операцию) создаётся:
  - Новый `AppDbContext`.
  - Новый `IPatientService`, который использует **текущий** `AppDbContext`.
- Нет конфликтов, нет утечек памяти.

---

## **3. Почему не Transient?**
- **`Transient`** создаёт **новый экземпляр каждый раз**, когда запрашивается зависимость.
- В случае с `IPatientService` это **неэффективно**:
  - Если в рамках одной операции (например, обработки одного пациента) сервис запрашивается несколько раз, то `Transient` создаст **несколько экземпляров**, что **лишнее**.
- **`Scoped` оптимален**:
  - Один экземпляр на операцию → **экономия ресурсов**.
  - Нет риска конфликтов (как в `Singleton`).

---

## **4. Как это работает в консольном приложении?**
В консольном приложении **нет HTTP-запросов**, поэтому `Scoped` привязывается к **явно созданному "scope"** (блоку кода):
```csharp
using var scope = serviceProvider.CreateScope();
// Внутри этого блока все Scoped-сервисы будут одинаковыми
var patientService = scope.ServiceProvider.GetRequiredService<IPatientService>();
```
- Это **эмулирует поведение веб-приложения**, где `Scoped` привязан к запросу.
- Гарантирует, что **все зависимости в рамках одной операции используют один и тот же контекст**.

---

## **5. Итог: Почему Scoped?**
| Причина                          | Пояснение                                                                                     |
|----------------------------------|---------------------------------------------------------------------------------------------|
| **Безопасность**                 | Избегает конфликтов с EF Core (контекст не потокобезопасен).                                |
| **Корректная работа с БД**        | Один контекст на одну операцию → нет проблем с отслеживанием изменений.                     |
| **Эффективность**                | Один экземпляр сервиса на операцию (не создаётся лишних объектов, как в `Transient`).        |
| **Совместимость с ASP.NET Core**| В веб-приложениях `Scoped` привязан к запросу, что удобно для миграции кода между проектами. |

---
### **Вывод**
- **`Scoped`** — оптимальный выбор для сервисов, работающих с **Entity Framework Core** или другими **непотокобезопасными ресурсами**.
- Гарантирует, что **все зависимости в рамках одной операции используют один и тот же контекст**.
- Избегает проблем с **многопоточностью** и **утечками памяти**.