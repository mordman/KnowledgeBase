В .NET для работы с асинхронными задачами (`Task`) существуют методы, которые позволяют управлять выполнением нескольких задач одновременно. Вот ключевые различия между ними:

---

### **1. `Task.WaitAll`**
- **Синхронно ждёт завершения всех переданных задач**.
- **Блокирует текущий поток**, пока все задачи не завершатся.
- **Использование**: редко, так как блокировка потока может привести к deadlock в UI или ASP.NET контексте.

**Пример:**
```csharp
Task task1 = Task.Run(() => Console.WriteLine("Task 1"));
Task task2 = Task.Run(() => Console.WriteLine("Task 2"));
Task.WaitAll(task1, task2); // Ждёт завершения обеих задач
```

---

### **2. `Task.WaitAny`**
- **Синхронно ждёт завершения любой из переданных задач**.
- **Блокирует текущий поток**, пока хотя бы одна задача не завершится.
- Возвращает индекс завершённой задачи.

**Пример:**
```csharp
Task task1 = Task.Run(() => Thread.Sleep(1000));
Task task2 = Task.Run(() => Thread.Sleep(500));
int completedIndex = Task.WaitAny(task1, task2); // Вернёт индекс task2
```

---

### **3. `Task.WhenAll`**
- **Асинхронно ждёт завершения всех переданных задач**.
- **Не блокирует поток**, возвращает `Task`, который завершится, когда завершатся все задачи.
- **Использование**: предпочтительный способ для асинхронного ожидания всех задач.

**Пример:**
```csharp
Task task1 = Task.Run(() => Console.WriteLine("Task 1"));
Task task2 = Task.Run(() => Console.WriteLine("Task 2"));
await Task.WhenAll(task1, task2); // Асинхронно ждёт завершения обеих задач
```

---

### **4. `Task.WhenAny`**
- **Асинхронно ждёт завершения любой из переданных задач**.
- **Не блокирует поток**, возвращает `Task`, который завершится, когда завершится первая задача.
- Возвращает завершённую задачу.

**Пример:**
```csharp
Task task1 = Task.Run(() => Thread.Sleep(1000));
Task task2 = Task.Run(() => Thread.Sleep(500));
Task completedTask = await Task.WhenAny(task1, task2); // Вернёт task2
```

---

### **5. `Task.WhenEach`**
- **Асинхронно перечисляет результаты задач по мере их завершения**
- **Не блокирует поток**, возвращает асинхронную перечисляемую последовательность
- **Использование**: когда нужно обрабатывать результаты задач сразу по готовности, а не ждать завершения всех

**Пример:**
```csharp
var tasks = new List<Task<int>>
{
    GetDataAsync("api/data1", 1000),
    GetDataAsync("api/data2", 500),
    GetDataAsync("api/data3", 1500)
};

await foreach (var result in Task.WhenEach(tasks))
{
    Console.WriteLine($"Получен результат: {result}");
}
```

---

### **Сводная таблица**

| Метод               | Блокирует поток? | Возвращаемое значение                     | Когда завершается?               |
|---------------------|-------------------|--------------------------------------------|-----------------------------------|
| `WaitAll`           | Да                | —                                          | Все задачи завершены             |
| `WaitAny`           | Да                | Индекс завершённой задачи                  | Любая задача завершена           |
| `WhenAll`           | Нет               | `Task` (завершается, когда все задачи)     | Все задачи завершены             |
| `WhenAny`           | Нет               | `Task` (первая завершённая задача)         | Любая задача завершена           |
| `WhenEach`          | Нет               | `IAsyncEnumerable<TResult>`                | Очереди, стриминг, обработка по мере готовности |
---

### **Когда что использовать?**
- **`WhenAll`**: когда нужно дождаться завершения всех задач (например, параллельная загрузка данных).
- **`WhenAny`**: когда нужно отреагировать на первую завершённую задачу (например, гонка задач или таймаут).
- **`WaitAll`/`WaitAny`**: только в редких случаях, когда блокировка потока допустима (например, в консольных приложениях).
- **`WhenEach`** — особенно полезен, когда нужно обрабатывать результаты по мере их готовности, не дожидаясь завершения всех задач.


---

## **`Task.WhenEach` в .NET 9**

### **Что делает?**
- **Асинхронно перебирает задачи** по мере их завершения.
- Позволяет **обрабатывать результаты задач в порядке их завершения**, а не в порядке запуска.
- Поддерживает **отмену** через `CancellationToken`.

### **Сигнатура метода**
```csharp
public static IAsyncEnumerable<TResult> WhenEach<TResult>(
    IEnumerable<Task<TResult>> tasks,
    CancellationToken cancellationToken = default
)
```

### **Пример использования**
```csharp
var tasks = new List<Task<int>>
{
    Task.Run(async () => { await Task.Delay(3000); return 1; }),
    Task.Run(async () => { await Task.Delay(1000); return 2; }),
    Task.Run(async () => { await Task.Delay(2000); return 3; })
};

await foreach (var result in Task.WhenEach(tasks))
{
    Console.WriteLine($"Завершена задача с результатом: {result}");
}
// Вывод:
// Завершена задача с результатом: 2
// Завершена задача с результатом: 3
// Завершена задача с результатом: 1
```

---

## **Сравнение с другими методами**

| Метод               | Назначение                                                                 | Блокирует поток? | Возвращаемое значение                     | Когда использовать?                          |
|---------------------|---------------------------------------------------------------------------|-------------------|--------------------------------------------|-----------------------------------------------|
| **`WhenEach`**      | Обработка результатов задач **по мере завершения** (потоковая обработка) | Нет               | `IAsyncEnumerable<TResult>`                | Очереди, стриминг, обработка по мере готовности |
| **`WhenAll`**       | Ожидание завершения **всех задач**                                        | Нет               | `Task<TResult[]>`                          | Когда нужны результаты всех задач сразу      |
| **`WhenAny`**       | Ожидание завершения **любой задачи**                                      | Нет               | `Task<Task<TResult>>`                      | Гонка задач, таймауты, приоритетная обработка |
| **`WaitAll`**       | Синхронное ожидание завершения **всех задач**                              | Да                | —                                          | Редко (например, в консольных приложениях)    |
| **`WaitAny`**       | Синхронное ожидание завершения **любой задачи**                           | Да                | Индекс задачи                              | Редко (например, в консольных приложениях)    |

---

## **Когда использовать `WhenEach`?**
- **Обработка потоков данных**: например, чтение результатов из нескольких асинхронных источников (API, базы данных) и обработка их по мере поступления.
- **Очереди задач**: когда задачи завершаются в разное время, и нужно сразу реагировать на каждую.
- **Экономия ресурсов**: вместо хранения всех результатов в памяти (как в `WhenAll`), можно обрабатывать их по одному.

---

## **Пример с отменой**
```csharp
var cts = new CancellationTokenSource(TimeSpan.FromSeconds(2));
try
{
    await foreach (var result in Task.WhenEach(tasks, cts.Token))
    {
        Console.WriteLine($"Результат: {result}");
    }
}
catch (OperationCanceledException)
{
    Console.WriteLine("Операция отменена!");
}
```

---

### **Вывод**
`WhenEach` — это мощный инструмент для **потоковой обработки асинхронных задач**, который появился в .NET 9. Он особенно полезен, когда нужно обрабатывать результаты по мере их готовности, не дожидаясь завершения всех задач.
