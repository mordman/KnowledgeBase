**CQRS (Command Query Responsibility Segregation)** — это архитектурный шаблон, который предлагает **разделить операции чтения (запросы) и записи (команды)** в приложении. Основная идея заключается в том, что модели для чтения и записи данных могут быть оптимизированы независимо друг от друга, что улучшает производительность, масштабируемость и гибкость системы.

---

## **Основные принципы CQRS**

### 1. **Разделение моделей**
- **Команды (Commands):** Изменяют состояние системы (например, создание, обновление, удаление данных).
- **Запросы (Queries):** Получают данные из системы (например, выборка, фильтрация, агрегация).

### 2. **Разные модели данных**
- Для **записи** может использоваться реляционная база данных (например, PostgreSQL) с нормализованной структурой.
- Для **чтения** — денормализованная база данных (например, Elasticsearch, MongoDB) или кэш (Redis), оптимизированный под конкретные запросы.

### 3. **Независимое масштабирование**
- Слой чтения и записи можно масштабировать независимо в зависимости от нагрузки.

---

## **Сценарии использования CQRS**

### 1. **Сложные бизнес-процессы**
- **Пример:** Системы бронирования (авиабилеты, отели), где операции записи (бронирование, отмена) и чтения (поиск свободных мест) требуют разных оптимизаций.

### 2. **Высокая нагрузка на чтение**
- **Пример:** Социальные сети, где пользователи часто просматривают ленту новостей, но редко публикуют новые посты.

### 3. **Разные требования к данным**
- **Пример:** Финансовые системы, где операции записи требуют строгой транзакционности, а аналитические запросы — быстрого доступа к агрегированным данным.

### 4. **Микросервисная архитектура**
- **Пример:** В микросервисах CQRS позволяет разделить ответственность между сервисами (например, один сервис обрабатывает команды, другой — запросы).

---

## **Преимущества CQRS**
| Преимущество                     | Описание                                                                 |
|-----------------------------------|--------------------------------------------------------------------------|
| **Оптимизация производительности** | Запросы и команды можно оптимизировать независимо.                     |
| **Гибкость**                     | Легко изменять модель чтения или записи без влияния на другую часть.    |
| **Масштабируемость**             | Можно масштабировать чтение и запись по отдельности.                    |
| **Упрощение кода**               | Логика чтения и записи разделена, что упрощает поддержку и тестирование. |

---

## **Недостатки CQRS**
| Недостаток                       | Описание                                                                 |
|-----------------------------------|--------------------------------------------------------------------------|
| **Сложность**                    | Требует дополнительных усилий для поддержки синхронизации данных.      |
| **Дублирование данных**          | Данные для чтения и записи могут храниться в разных базах.             |
| **Задержки синхронизации**       | При использовании асинхронной репликации данные могут быть неактуальными. |

---

## **Пример реализации CQRS**

### **1. Команды (Write Model)**
```csharp
// Команда на создание пользователя
public class CreateUserCommand : IRequest<int>
{
    public string Name { get; set; }
    public string Email { get; set; }
}

// Обработчик команды
public class CreateUserCommandHandler : IRequestHandler<CreateUserCommand, int>
{
    private readonly IUserRepository _repository;

    public CreateUserCommandHandler(IUserRepository repository)
    {
        _repository = repository;
    }

    public async Task<int> Handle(CreateUserCommand request, CancellationToken cancellationToken)
    {
        var user = new User { Name = request.Name, Email = request.Email };
        await _repository.AddAsync(user);
        return user.Id;
    }
}
```

### **2. Запросы (Read Model)**
```csharp
// Запрос на получение пользователей
public class GetUsersQuery : IRequest<List<UserDto>> { }

// Обработчик запроса
public class GetUsersQueryHandler : IRequestHandler<GetUsersQuery, List<UserDto>>
{
    private readonly IUserReadRepository _readRepository;

    public GetUsersQueryHandler(IUserReadRepository readRepository)
    {
        _readRepository = readRepository;
    }

    public async Task<List<UserDto>> Handle(GetUsersQuery request, CancellationToken cancellationToken)
    {
        return await _readRepository.GetAllAsync();
    }
}
```

---

## **Когда использовать CQRS?**
- Если в вашем приложении **много операций чтения и мало записи** (или наоборот).
- Если вам нужно **масштабировать чтение и запись независимо**.
- Если бизнес-логика **сложная и требует разных оптимизаций** для чтения и записи.

---