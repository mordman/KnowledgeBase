## **1. Монолитная архитектура (Monolithic Architecture)**



## Оглавление
- [**1. Монолитная архитектура (Monolithic Architecture)**](#1-монолитная-архитектура-monolithic-architecture)
  - [**Описание**](#описание)
- [**Подстили и шаблоны**](#подстили-и-шаблоны)
  - [**1.1. Классический монолит (Classic Monolith)**](#11-классический-монолит-classic-monolith)
    - [**Описание**](#описание)
    - [**Проблемы**](#проблемы)
  - [**1.2. Модульный монолит (Modular Monolith)**](#12-модульный-монолит-modular-monolith)
    - [**Описание**](#описание)
    - [**Преимущества**](#преимущества)
  - [**1.3. Слоёный монолит (Layered Monolith)**](#13-слоёный-монолит-layered-monolith)
    - [**Описание**](#описание)
    - [**Слои**](#слои)
    - [**Проблемы**](#проблемы)
  - [**1.4. Onion Architecture (Луковая архитектура)**](#14-onion-architecture-луковая-архитектура)
    - [**Описание**](#описание)
    - [**Слои**](#слои)
    - [**Преимущества**](#преимущества)
  - [**1.5. Ports and Adapters (Hexagonal Architecture)**](#15-ports-and-adapters-hexagonal-architecture)
    - [**Описание**](#описание)
    - [**Компоненты**](#компоненты)
    - [**Преимущества**](#преимущества)
- [**Пример реализации на C# (Modular Monolith)**](#пример-реализации-на-c-modular-monolith)
- [**Когда использовать монолит?**](#когда-использовать-монолит)

  - [**Описание**](#описание)
  - [**1.1. Классический монолит (Classic Monolith)**](#11-классический-монолит-classic-monolith)
    - [**Описание**](#описание)
    - [**Проблемы**](#проблемы)
  - [**1.2. Модульный монолит (Modular Monolith)**](#12-модульный-монолит-modular-monolith)
    - [**Описание**](#описание)
    - [**Преимущества**](#преимущества)
  - [**1.3. Слоёный монолит (Layered Monolith)**](#13-слоёный-монолит-layered-monolith)
    - [**Описание**](#описание)
    - [**Слои**](#слои)
    - [**Проблемы**](#проблемы)
  - [**1.4. Onion Architecture (Луковая архитектура)**](#14-onion-architecture-луковая-архитектура)
    - [**Описание**](#описание)
    - [**Слои**](#слои)
    - [**Преимущества**](#преимущества)
  - [**1.5. Ports and Adapters (Hexagonal Architecture)**](#15-ports-and-adapters-hexagonal-architecture)
    - [**Описание**](#описание)
    - [**Компоненты**](#компоненты)
    - [**Преимущества**](#преимущества)
### **Описание**
Монолитная архитектура — это подход, при котором всё приложение (интерфейс, бизнес-логика, доступ к данным) объединено в **единый блок** и развёртывается как одно целое. Такой стиль часто используется на ранних этапах разработки из-за простоты развёртывания и тестирования.

---

## **Подстили и шаблоны**

---

### **1.1. Классический монолит (Classic Monolith)**
#### **Описание**
Все компоненты приложения (UI, бизнес-логика, доступ к данным) тесно связаны и развёртываются вместе.

```mermaid
graph TD
    A[Классический монолит] --> B[UI]
    A --> C[Бизнес-логика]
    A --> D[Доступ к данным]
    B -->|Вызывает| C
    C -->|Вызывает| D
```

#### **Проблемы**
- Сложность масштабирования (масштабируется всё приложение целиком).
- Высокая связанность компонентов, что усложняет поддержку и тестирование.

---

### **1.2. Модульный монолит (Modular Monolith)**
#### **Описание**
Приложение разбито на **логические модули** (например, "Пользователи", "Заказы", "Платежи"), но развёртывается как единое целое. Модули взаимодействуют через интерфейсы.

```mermaid
graph TD
    A[Модульный монолит] --> B[Модуль Пользователи]
    A --> C[Модуль Заказы]
    A --> D[Модуль Платежи]
    B -->|Интерфейс| E[Общий интерфейс]
    C -->|Интерфейс| E
    D -->|Интерфейс| E
```

#### **Преимущества**
- Проще поддерживать, чем классический монолит.
- Легче тестировать и вносить изменения в отдельные модули.

---

### **1.3. Слоёный монолит (Layered Monolith)**
#### **Описание**
Приложение разбито на **слои** (UI, бизнес-логика, доступ к данным), но все слои развёртываются вместе.

```mermaid
graph TD
    A[Слоёный монолит] --> B[Presentation Layer]
    A --> C[Business Logic Layer]
    A --> D[Data Access Layer]
    B -->|Вызывает| C
    C -->|Вызывает| D
```

#### **Слои**
1. **Presentation Layer** (UI, API)
2. **Business Logic Layer** (бизнес-правила)
3. **Data Access Layer** (работа с базой данных)

#### **Проблемы**
- Может превратиться в "большой комок грязи" (Big Ball of Mud), если слои сильно связаны.
- Сложно масштабировать отдельные слои.

---

### **1.4. Onion Architecture (Луковая архитектура)**
#### **Описание**
Приложение организовано в **концентрические слои**, где внутренние слои не зависят от внешних. Бизнес-логика находится в центре, а инфраструктура (базы данных, фреймворки) — на внешнем слое.

```mermaid
graph TD
    A[Onion Architecture] --> B[UI/API/Tests]
    A --> C[Infrastructure]
    A --> D[Application Core]
    A --> E[Domain Layer]
    B -->|Зависит от| D
    C -->|Зависит от| D
    D -->|Зависит от| E
```

#### **Слои**
- **UI/API/Tests** (внешний слой)
- **Infrastructure** (базы данных, фреймворки)
- **Application Core** (юзкейсы, интерфейсы)
- **Domain Layer** (бизнес-логика, сущности)

#### **Преимущества**
- Высокая тестируемость и гибкость.
- Лёгкость замены внешних компонентов (например, базы данных).

---

### **1.5. Ports and Adapters (Hexagonal Architecture)**
#### **Описание**
Приложение разделено на **ядро** (бизнес-логика) и **адаптеры** (интерфейсы для взаимодействия с внешним миром). Позволяет легко заменять адаптеры (например, базу данных или UI).

```mermaid
graph TD
    A[Hexagonal Architecture] --> B[Application Core]
    A --> C[Adaptors]
    C -->|Реализуют| D[Ports]
    B -->|Определяет| D
    D -->|UI| C
    D -->|DB| C
    D -->|External Services| C
```

#### **Компоненты**
- **Application Core** (бизнес-логика, доменные модели)
- **Ports** (интерфейсы для взаимодействия с внешним миром)
- **Adaptors** (реализации портов: UI, базы данных, внешние сервисы)

#### **Преимущества**
- Низкая связанность.
- Легкость тестирования и замены компонентов.

---

## **Пример реализации на C# (Modular Monolith)**
```csharp
// Пример модуля "Пользователи" в модульном монолите
namespace UserModule
{
    public interface IUserRepository
    {
        User GetById(int id);
        void Save(User user);
    }

    public class UserService
    {
        private readonly IUserRepository _userRepository;

        public UserService(IUserRepository userRepository)
        {
            _userRepository = userRepository;
        }

        public void RegisterUser(string name, string email)
        {
            var user = new User(name, email);
            _userRepository.Save(user);
        }
    }
}
```

---

## **Когда использовать монолит?**
- Для **небольших проектов** или MVP.
- Когда команда **небольшая** и не требуется масштабирование отдельных компонентов.
- Если **инфраструктура простая** и не требуется высокая гибкость.