## **4. Fallback (Резервный вариант)**
### **Цель**
Вернуть заранее подготовленный ответ или выполнить альтернативную логику, если основной запрос failed.

---

### **Принцип работы**
- Если основной запрос завершился с ошибкой, система возвращает fallback-ответ (например, кэшированные данные).
- Часто используется вместе с **Circuit Breaker** или **Retry**.

---

### **Пример на C# (Polly)**
```csharp
using Polly;
using System;
using System.Net.Http;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        var fallbackPolicy = Policy<string>
            .Handle<Exception>()
            .FallbackAsync(
                fallbackValue: "Fallback response",
                onFallback: (exception) =>
                {
                    Console.WriteLine($"Использован fallback из-за ошибки: {exception.Message}");
                    return Task.CompletedTask;
                });

        HttpClient httpClient = new HttpClient();

        string result = await fallbackPolicy.ExecuteAsync(async () =>
        {
            HttpResponseMessage response = await httpClient.GetAsync("https://example.com/api");
            response.EnsureSuccessStatusCode();
            return await response.Content.ReadAsStringAsync();
        });

        Console.WriteLine(result); // Выведет "Fallback response", если запрос failed
    }
}
```

---

### **Пример с Kafka**
Если consumer не может обработать сообщение, он отправляет его в fallback-топик:
```csharp
using Confluent.Kafka;
using Polly;
using System;
using System.Threading.Tasks;

class KafkaFallbackExample
{
    static async Task Main()
    {
        var config = new ConsumerConfig { GroupId = "example-group", BootstrapServers = "localhost:9092" };
        var fallbackPolicy = Policy
            .Handle<Exception>()
            .FallbackAsync(async (ct) =>
            {
                using (var producer = new ProducerBuilder<Null, string>(new ProducerConfig { BootstrapServers = "localhost:9092" }).Build())
                {
                    await producer.ProduceAsync("fallback-topic", new Message<Null, string> { Value = "Fallback message" });
                }
            });

        using (var consumer = new ConsumerBuilder<Ignore, string>(config).Build())
        {
            consumer.Subscribe("example-topic");

            while (true)
            {
                var consumeResult = consumer.Consume();
                await fallbackPolicy.ExecuteAsync(async () =>
                {
                    if (consumeResult.Message.Value.Contains("error"))
                    {
                        throw new Exception("Ошибка обработки!");
                    }
                    Console.WriteLine($"Обработано сообщение: {consumeResult.Message.Value}");
                });
            }
        }
    }
}
```

---

### **Плюсы и минусы**
| Плюсы                                      | Минусы                                      |
|--------------------------------------------|---------------------------------------------|
| Обеспечивает graceful degradation.         | Может снизить точность данных.              |
| Улучшает пользовательский опыт.            | Требует поддержки альтернативной логики.    |