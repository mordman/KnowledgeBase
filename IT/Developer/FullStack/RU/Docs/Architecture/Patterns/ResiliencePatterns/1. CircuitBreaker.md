## **1. Circuit Breaker (Предохранитель)**
### **Цель**
Защитить систему от каскадных сбоев при нестабильности внешних зависимостей (например, API, базы данных). Если внешний сервис начинает часто возвращать ошибки, Circuit Breaker "размыкает" цепь, прекращая запросы к нему на определённое время.

---

### **Принцип работы**
Circuit Breaker имеет **три состояния**:
1. **Closed (Замкнут)**
   - Запросы проходят к внешней службе.
   - Если количество ошибок превышает порог, переходит в **Open**.
2. **Open (Разомкнут)**
   - Запросы немедленно отклоняются (или возвращается fallback-ответ).
   - Через заданный таймаут переходит в **Half-Open**.
3. **Half-Open (Полуоткрыт)**
   - Разрешает ограниченное количество запросов для проверки работоспособности службы.
   - Если запросы успешны — возвращается в **Closed**, иначе — обратно в **Open**.

---

### **Пример на C# (Polly)**
```csharp
using Polly;
using Polly.CircuitBreaker;
using System;
using System.Net.Http;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        // Настраиваем Circuit Breaker
        AsyncCircuitBreakerPolicy breaker = Policy
            .Handle<HttpRequestException>()
            .CircuitBreakerAsync(
                exceptionsAllowedBeforeBreaking: 3, // Количество ошибок до размыкания
                durationOfBreak: TimeSpan.FromSeconds(30) // Время в состоянии Open
            );

        HttpClient httpClient = new HttpClient();

        for (int i = 0; i < 10; i++)
        {
            try
            {
                await breaker.ExecuteAsync(async () =>
                {
                    HttpResponseMessage response = await httpClient.GetAsync("https://example.com/api");
                    response.EnsureSuccessStatusCode();
                    Console.WriteLine("Запрос успешен!");
                });
            }
            catch (BrokenCircuitException)
            {
                Console.WriteLine("Circuit Breaker разомкнут! Запрос не выполнен.");
            }
            catch (HttpRequestException)
            {
                Console.WriteLine("Ошибка запроса.");
            }

            await Task.Delay(1000);
        }
    }
}
```

---

### **Пример с Kafka**
Если consumer Kafka зависит от внешнего API, Circuit Breaker может временно приостановить потребление сообщений при сбоях API:
```csharp
using Confluent.Kafka;
using Polly;
using Polly.CircuitBreaker;
using System;
using System.Threading;

class KafkaCircuitBreakerExample
{
    static async Task Main()
    {
        var config = new ConsumerConfig
        {
            GroupId = "example-group",
            BootstrapServers = "localhost:9092",
            AutoOffsetReset = AutoOffsetReset.Earliest
        };

        AsyncCircuitBreakerPolicy breaker = Policy
            .Handle<Exception>()
            .CircuitBreakerAsync(3, TimeSpan.FromSeconds(30));

        using (var consumer = new ConsumerBuilder<Ignore, string>(config).Build())
        {
            consumer.Subscribe("example-topic");

            try
            {
                while (true)
                {
                    var consumeResult = consumer.Consume(CancellationToken.None);

                    await breaker.ExecuteAsync(async () =>
                    {
                        bool isApiAvailable = await CallExternalApi(consumeResult.Message.Value);
                        if (!isApiAvailable)
                        {
                            throw new Exception("API недоступен!");
                        }
                        Console.WriteLine($"Обработано сообщение: {consumeResult.Message.Value}");
                    });
                }
            }
            catch (BrokenCircuitException)
            {
                Console.WriteLine("Circuit Breaker разомкнут! Потребление приостановлено.");
                await Task.Delay(30000); // Ждём восстановления
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ошибка: {ex.Message}");
            }
        }
    }

    static async Task<bool> CallExternalApi(string message)
    {
        await Task.Delay(100);
        if (message.Contains("error"))
        {
            return false; // Имитация ошибки
        }
        return true;
    }
}
```

---

### **Плюсы и минусы**
| Плюсы                                      | Минусы                                      |
|--------------------------------------------|---------------------------------------------|
| Предотвращает каскадные сбои.              | Требует настройки порогов и времени ожидания. |
| Уменьшает нагрузку на неисправный сервис.  | Может маскировать реальные проблемы.        |
| Позволяет системе восстановиться.          | Не подходит для критически важных операций.  |